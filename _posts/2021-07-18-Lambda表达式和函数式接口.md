--- 
layout: post
title: Lambda表达式和函数式接口
tags:
- Java8攻略大全
status: publish
type: post
published: true
top: false
---

> Lambda表达式
    
    Lambda 表达式是一个匿名函数，我们可以把 Lambda表达式理解为是一段可以传递的代码(将代码像数据一样进行传递——行为参数化)。可以写出更简洁、更灵活的代码

> Lambda 表达式语法
  
    (parameters) -> expression 或(parameters) ->{ statements; }

    Lambda 表达式在 Java 语言中引入了一个新的语法元素和操作符。这个操作符为 “->” ， 该操作符被称为 Lambda 操作符或剪头操作符。它将 Lambda 分为两个部分：

    左侧：指定了 Lambda 表达式需要的所有参数

    右侧：指定了 Lambda 体，即 Lambda 表达式要执行的功能
&nbsp;
> Lambda表达式实例

      Java8 内置的四大核心函数式接口
       Consumer<T> : 消费型接口  void accept(T t); BiConsumer<T,U> 两个参数
       Supplier<T> : 供给型接口   T get();
       Function<T, R> : 函数型接口  R apply(T t);  BiFunction<T,U,R>
       Predicate<T> : 断言型接口   boolean test(T t); BiPredicate<T,U>
  > Consumer<T> : 消费型接口 
  
接收一个参数T；无返回值
```
 //Consumer<T> 消费型接口 
    public static void modifyValue(Integer value, Consumer<Integer> consumer) {
        consumer.accept(value);
    }

    public static void testConsumer() {
        modifyValue(3, s -> System.out.println(s * 3));
    }

```
拓展 BiConsumer<T,U> 接收两个参数；无返回值

> Supplier<T> : 供给型接口

无参数；有返回值T

```
  //Supplier<T> 供给型接口 :产生指定个数的整数，并放入集合
    public static List<Integer> getNumList(int num, Supplier<Integer> supplier) {
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < num; i++) {
            Integer n = supplier.get();
            list.add(n);
        }
        return list;
    }
    public static void testSupplier() {
        List<Integer> numList = getNumList(10, () -> (int) (Math.random() * 100));

        for (Integer num : numList) {
            System.out.println(num);
        }
    }

```
> Function<T, R> : 函数型接口

接收一个参数T； 返回值R  
```
   // Function<T, R> 函数型接口：处理字符串
    public static String strHandler(String str, Function<String, String> function) {
        return function.apply(str);
    }
    public static void testFunction() {
        String str1 = strHandler("测试内置函数式接口", s -> s.substring(2));
        System.out.println(str1);

        String str2 = strHandler("abcdefg", s -> s.toUpperCase());
        System.out.println(str2);
    }

``` 
拓展 BiFunction<T,U,R> 接收两个参数T,U；返回值T

> Predicate<T> : 断言型接口

  接收一个参数T； 返回值boolean

```
   //Predicate<T> 断言型接口：将满足条件的字符串放入集合
    public static List<String> filterStr(List<String> list, Predicate<String> predicate) {
        List<String> newList = new ArrayList<>();
        for (String s : list) {
            if (predicate.test(s)) {
                newList.add(s);
            }
        }
        return newList;
    }
    public static void testPredicate() {
        List<String> list = Arrays.asList("hello", "java8", "function", "predicate");
        List<String> newList = filterStr(list, s -> s.length() > 5);
        for (String s : newList) {
            System.out.println(s);
        }
    }
``` 
拓展 BiPredicate<T,U> 接收两个参数T,U；返回值boolean

>  @FunctionalInterface : 自定义函数式接口

```
 @FunctionalInterface
    public interface Test<T> {
        T get(T t);
    }
    /**
     * 
     * @param 'Lambda'操作
     * @param ' 参数'
     * @return
     */
    public static Integer getInteger(Test<Integer> test,Integer integer) {
        return test.get(integer);
    }
    public static void main(String[] args) {
        getInteger(e->(e+1),1 );
```
作为参数传递 Lambda 表达式

 ![](/upload/image/function.png){:width="800px"}

 [Package java.util.function](https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html)


    Java类型要么是引用类型（Byte、Integer、Objuct、List），要么是原始类型（int、double、byte、char）。但是泛型只能绑定到引用类型。将原始类型转换为对应的引用类型，叫装箱
    相反，将引用类型转换为对应的原始类型，叫拆箱。
    当然Java提供了自动装箱机制帮我们执行了这一操作。
```
List<Integer> list = new ArrayList();
for (int i = 0; i < 10; i++) {
list.add(i);    //int被装箱为Integer
}
```

     但这在性能方面是要付出代价的。装箱后的值本质上就是把原始类型包裹起来，并保存在堆里。因此，装箱后的值需要更多的内存，并需要额外的内存搜索来获取被包裹的原始值。
     以上funciton包中的IntPredicate、DoubleConsumer、LongBinaryOperator、ToDoubleFuncation等就是避免自动装箱的操作。
    一般，针对专门的输入参数类型的函数式接口的名称都要加上对应的原始类型前缀。

---
参考：

    https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html

    http://www.starfish.ink/java/Java-8.html







