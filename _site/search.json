[
  
    {
      "title"       : "7大设计原则",
      "category"    : "",
      "tags"        : "设计模式",
      "url"         : "./%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.html",
      "date"        : "2022-05-19 03:32:20 +0800",
      "description" : "简单工厂模式",
      "content"     : "合成复用原则合成（组合）/ 聚合复用原则定义：尽量使用对象组合/聚合，而不是继承关系达到软件复用的目的 聚合 has-A 组合 contains-A 继承 is-A优点：可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少何时使用合成/聚合、继承聚合：大雁去群的例子；笔记本和 U 盘，笔记本没了，U 盘还能独立存在组合：集成显卡和笔记本，显卡坏了，你电脑也不能用了，看不见，不能操作了代码场景：a 类中有一个 b类的引用 聚合：除了 a 类以外，还有其他地方对 b 类的引用，就算 a 类结束了，b 还存活着 组合：只有 a 类引用，那么当 a 类结束时， b 类跟着一起结束Coding场景：Dao 层获取数据库连接；public class DBConnection { public String getConnection() { return \"使用 Mysql 数据库连接\"; }}public class ProductDao extends DBConnection { public void addProduct() { String connection = super.getConnection(); System.out.println(\"使用 \" + connection + \" 添加产品\"); }}public class Test { public static void main(String[] args) { ProductDao productDao = new ProductDao(); productDao.addProduct(); }}需求来了：增加了 Postgresql 数据库，要切换数据源怎么办？在上面的示例中，可能的修改如下： 增加 PostgresqlConnection 修改 ProductDao的继承类 在 DBConnection 中新增获取 PostgresqlConnection 的方法上面这样做，都破坏了开闭原则。下面使用合成/复用原则来改造合成/复用 改造场景public interface DBConnection { String getConnection();}public class MysqlDBConnection implements DBConnection { @Override public String getConnection() { return \"使用 Mysql 数据库连接\"; }}public class PostgreesqlDBConnection implements DBConnection { @Override public String getConnection() { return \"使用 Postgreesql 数据库连接\"; }}public class ProductDao { private DBConnection dbConnection; public void addProduct() { String connection = dbConnection.getConnection(); System.out.println(\"使用 \" + connection + \" 添加产品\"); } public void setDbConnection(DBConnection dbConnection) { this.dbConnection = dbConnection; }}public class Test { public static void main(String[] args) { ProductDao productDao = new ProductDao(); productDao.setDbConnection(new MysqlDBConnection());// productDao.setDbConnection(new PostgreesqlDBConnection()); productDao.addProduct(); }}组合，一对一，强依赖。符合开闭原则，也符合里氏替换原则。随意替换数据源迪米特原则定义：一个对象应该对其他对象保持最少的了解。又叫最少知道原则核心：尽量降低类与类之间的耦合优点：降低类之间的耦合强调：纸盒朋友交流，不和陌生人说话什么是朋友？出现在成员变量、方法的输入、输出参数中的类称为朋友类，而出现在方法体内部的类不属于朋友类coding场景：老板给小组长下达指令，查询在线课程数量public class Boss { public void commandCheckNumber(TeamLeader teamLeader) { // 老板获取到所有的课程 List&lt;Course&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 20; i++) { list.add(new Course()); } // 对小组长下达检查指令 teamLeader.checkNumber(list); }}public class TeamLeader { public void checkNumber(List&lt;Course&gt; list) { // 假设在检查逻辑 System.out.println(\"在线课程数量是：\" + list.size()); }}public class Course {}public class Test { public static void main(String[] args) { Boss boss = new Boss(); TeamLeader teamLeader = new TeamLeader(); boss.commandCheckNumber(teamLeader); }}在线课程数量是：20对于这个场景来说，boss 是不需要知道 Course 的，只要给 TeamLeader 下达指令，然后 TeamLeader 报告结果即可。哪些是 Boss 的朋友？ TeamLeader （入参）哪些不是 Boss 的朋友？ Course，既不是成员变量、方法的输入、输出参数，而只是方法体内部的类。迪米特原则改造只是把非朋友类逻辑移动到 TeamLeader 中了。public class TeamLeader { public void checkNumber() { // 老板获取到所有的课程 List&lt;Course&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 20; i++) { list.add(new Course()); } System.out.println(\"在线课程数量是：\" + list.size()); }}这里对于 TeamLeader 来说，Course 貌似又不是它的朋友了，但是这个是属于 TeamLeader 的职责依赖倒置原则定义：高层模块（指应用模块）不应该依赖底层模块，二者都应该依赖其抽象 抽象不应该依赖细节；细节应该依赖抽象 针对接口编程，不要针对实现编程核心思想：面向接口编程优点： 减少类之间的耦合性 提高系统稳定性 提高代码可读性和维护性 可降低修改程序锁造成的风险coding场景：Geely 在慕课上学习课程，学习 Java 课程，学习前端课程。package cn.mrcode.newstudy.design.pattern.principle.dependencyinversion;public class Geely { public void studyJavaCourse() { System.out.println(\"Geely 在学习 Java 课程\"); } public void studyFECourse() { System.out.println(\"Geely 在学习 FE 课程\"); }}package cn.mrcode.newstudy.design.pattern.principle.dependencyinversion;public class Test { public static void main(String[] args) { Geely geely = new Geely(); geely.studyJavaCourse(); geely.studyFECourse(); }}Geely 在学习 Java 课程Geely 在学习 FE 课程现在的问题是：如果要再增加一门学习课程呢？那么解决的方案只能在 Geely 类中增加另外一门课程的方法，然后Test（应用层）再调用该方法这破坏了_依赖倒置原则_，Test(应用层)依赖Geely（底层模块）。下面使用依赖倒置原则来进行修改public interface ICourse { void studyCourse();}public class JavaCourse implements ICourse { @Override public void studyCourse() { System.out.println(\"Geely 在学习 Java 课程\"); }}public class FECourse implements ICourse { @Override public void studyCourse() { System.out.println(\"Geely 在学习 FE 课程\"); }}public class Geely { public void studyImoocCourse(ICourse iCourse) { iCourse.studyCourse(); }}public static void main(String[] args) { // v1 不使用依赖倒置原则// Geely geely = new Geely();// geely.studyJavaCourse();// geely.studyFECourse();// geely.studyPythonCourse(); Geely geely = new Geely(); geely.studyImoocCourse(new JavaCourse()); geely.studyImoocCourse(new FECourse());}上面这个示例： geely 学习什么课程由 Test（应用层决定，高层模块） 再学习其他的课程，只需要扩展课程即可。而 geely 不需要变动 在底层模块扩展 是扩展课程，而不是去修改已有的 JavaCourse ，这也符合了_开闭原则_ 面向接口编程，而不是面对 Geely Test 与 Geely 是解耦的 Gelly 与 具体的课程实现是解耦的 Gelly 与 ICourse 是有依赖的 所谓高内聚，低耦合，就是尽量减少耦合这里只是一种写法， 由方法参数传递进去， 还可以从构造函数传递（不过这样一个 geely 实例就只能学习一种课程了） 还可以设置一个set方法，每次学习前，把课程set进去// v3// Geely geely = new Geely(new JavaCourse());// geely.studyImoocCourse();Geely geely = new Geely();geely.setCourse(new JavaCourse())geely.studyImoocCourse();geely.setCourse(new FECourse())geely.studyImoocCourse();依赖倒置原则表现了一种事实： 相对于细节的多变性，抽象的东西要稳定得多 以抽象搭建起来的架构，比以细节搭建起来的要稳定得多那么抽象的目的也就是：制定好规范和契约，如 ICourse 就是一种规范契约接口隔离原则定义：用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口 一个类（泛指，）对一个类的依赖应该建立在虚小的接口上 建立单一接口，不要建立庞大臃肿的接口 尽量细化接口，接口中的方法尽量少 注意湿度原则，一定要适度 如果只是尽可能的一个接口一个方法的话，那么接口类将爆炸，复杂性更高 优点：符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的： 可读性 可扩展性 可维护性高内聚：减少对外的交互，使接口中最少的方法去完成最多的事情一定要适度，在实际开发过程中，还要考虑业务模型，包括预判未来可能变更的地方coding// 动物行为public interface IAnimalAction { void eat(); void fly(); // 飞 void swim(); // 游泳}public class Dog implements IAnimalAction { @Override public void eat() { } @Override public void fly() { // 狗不会飞 } @Override public void swim() { }}对于狗来说，其他两种行为都ok，但是不会飞。假如再增加一种鸟类动物大雁，大雁不会游泳。那么使用接口隔离原则来实现的一种可能：将接口拆分public interface IEatAnimalAction { void eat();}public interface IFlyAnimalAction { void fly();}public interface ISwimAnimalAction { void swim();}public class Bird implements IFlyAnimalAction, IEatAnimalAction { @Override public void eat() { } @Override public void fly() { }}这样就将行为给隔离开了。也不会有空实现方法了；那么 单一职责原则和接口隔离原则有什么不同呢? 单一职责原则：约束的是类，接口，方法的职责是单一的 也就是说，在一个接口中，只要职责是单一的，有多个方法也可以 如：游泳：有狗刨，自由泳等 针对的是程序中的实现和细节 接口隔离原则：主要约束的是接口， 针对抽象，整体，程序框架的构建 还是适度，看项目规模、业务模型，不要一个简单的业务就搞了n个接口和类，开发起来也麻烦里氏替换原则Liskov Substitution Principle LSP稍微有点难。不过不要慌定义：如果对每一个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都替换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1的子类型。提取关键词解读： T1 类有对象 o1 T2 类有对象 o2 P 程序当把程序中依赖 o1 对象全部替换成 o2 时，程序的行为没有发生变化。那么就可以认定为：T2 是 T1的子类型里氏替换原则是对开闭原则的一个补充： 开闭原则：面向抽象编程，要抽象 里氏替换原则：可以被替换，那么就有抽象；对实现抽象化的具体步骤规范比如：我们自定义一个类继承了ArrayList，但是重写get(indix)方法时，把索引改成从1开始了，那么这样的虽然有抽象，但是行为发生了变化，这样也不被认为 自定义的是 ArrayList的子类型 上面这个比喻：我没有明白，懵逼了定义扩展：一个软件实体如果适用一个父类的话，那一定适用于其子类，所有引用父类的地方必须能透明地适用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变在 java 中来说，只要只继承了某父类，那么就被认定为是其子类型，但是对于里氏替换原则来说，就算继承了，但是导致替换后，行为发生了变化，则被认定为是不合法的引申意义：子类可以扩展父类的功能，但不能改变父类原有的功能。 含义 1：子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 含义 2：子类中可以增加自己特有的方法。 对于开闭原则中的例子如下，就有一个含义（含义 2）被破坏了，JavaDiscountCourse 在扩展父类功能的时候，改变了 getPrice 的含义 public static void main(String[] args) { ICourse iCourse = new JavaDiscountCourse(96, \"设计模式\", 389d); JavaDiscountCourse javaCourse = (JavaDiscountCourse) iCourse; System.out.println(\"ID:\" + javaCourse.getId() + \"，课程名称：\" + javaCourse.getName() + \"，价格：\" + javaCourse.getPrice() + \", 原价：\" + javaCourse.getOriginPrice() ); } 通过上面的知识点来回想自己在实际工作中，经常会重写父类的方法，这样写起来的确简单快捷，但是在一定程度上导致了整个继承体系的可复用性比较差，特别是使用多态频繁的时候，出错的几率会大大增加。 含义 3 ：当子类的方法重载父类的方法时，方法的前置条件（既方法的入参）要比父类的入参更宽松。 含义 4 ：当子类的方法实现父类的方法时（重写/重载或实现抽象方法）方法的后置条件（及方法的返回值）要比如雷更严格或相等。优点： 约束继承泛滥，开闭原则的一种体现 如：Persion 中有一个 生娃 的方法，子类可能有白人、黑人、黄种人，这是可以的，符合里氏替换原则。但是，来一个男人，机器人，这就是一个继承泛滥的表现 加强程序的健壮性，同时变更时也可以做到非常好的兼容性，提高程序的维护性，扩展性。降低需求变更时引入的风险。 coding从类层面演示场景：正方形和长方形，我们认为正方形是一种特殊的长方形。// 长方形public class Rectangle { private long length; private long width; public long getLength() { return length; } public void setLength(long length) { this.length = length; } public long getWidth() { return width; } public void setWidth(long width) { this.width = width; }}// 正方形：来验证在某些场景下，正方形是否是长方形public class Square extends Rectangle { // 边长：正方形的长宽是一样的 private long sideLength; public long getSideLength() { return sideLength; } public void setSideLength(long sideLength) { this.sideLength = sideLength; } @Override public long getLength() { return getSideLength(); } @Override public void setLength(long length) { setSideLength(length); } @Override public long getWidth() { return getSideLength(); } @Override public void setWidth(long width) { setSideLength(width); }}public class Test { public static void resize(Rectangle rectangle) { while (rectangle.getWidth() &lt;= rectangle.getLength()) { rectangle.setWidth(rectangle.getWidth() + 1); System.out.println(\"width:\" + rectangle.getWidth() + \" length:\" + rectangle.getLength()); } System.out.println(\"resize 方法结束：width:\" + rectangle.getWidth() + \" length:\" + rectangle.getLength()); } public static void main(String[] args) { Rectangle rectangle = new Rectangle(); rectangle.setLength(20); rectangle.setWidth(10); resize(rectangle); Square square = new Square(); square.setSideLength(10); resize(square); }}输出width:20 length:20width:21 length:20resize 方法结束：width:21 length:20width:239722 length:239722width:239723 length:239723会发现，在验证 resize 场景中，正方形是否是长方形这一子类的时候，替换之后，再次运行 resize 方法的时候，行为改变了，不能结束了；那么这个时候就要考虑正方形继承长方形是否是正确的了，假设之前的鸟类，我们认为飞的行为就是鸟类的特性，但是鸵鸟就是不能飞，强行让鸵鸟继承鸟，则有可能会造成与这里一致的情况。行为被改变了。那么这里来继续重构，解耦正方形和长方形；他们都是四边形；public interface Quadrangle { long getLength(); long getWidth();}public class Rectangle implements Quadrangle { private long length; private long width; public void setLength(long length) { this.length = length; } public void setWidth(long width) { this.width = width; } @Override public long getLength() { return 0; } @Override public long getWidth() { return 0; }}public class Square implements Quadrangle { // 边长：正方形的长宽是一样的 private long sideLength; public long getSideLength() { return sideLength; } public void setSideLength(long sideLength) { this.sideLength = sideLength; } @Override public long getLength() { return getSideLength(); } @Override public long getWidth() { return getSideLength(); }}那么就会发现，没有办法设置宽度了。对于 resize 场景来说，正方形是不适合该场景的；所以这里还是只能用于长方形。说明了，长方形和正方形在该场景中不适合里氏替换原则的public static void resize(Quadrangle rectangle) { while (rectangle.getWidth() &lt;= rectangle.getLength()) { // 没有办法 setWidth rectangle.setWidth(rectangle.getWidth() + 1); System.out.println(\"width:\" + rectangle.getWidth() + \" length:\" + rectangle.getLength()); } System.out.println(\"resize 方法结束：width:\" + rectangle.getWidth() + \" length:\" + rectangle.getLength());}通过这个例子，能深刻的理解里氏替换原则在我们软件设计中存在的巨大作用。同时也约束我们，子类的行为与父类应该保持一致，如果子类达不到这一点，那么子类就会违反里氏替换原则。在实际过程中，是多人协同开发的，甚至通过层层包装后，再使用，如果这个时候，对于 resize 场景不采用里氏替换原则来约束，那么就将产生与预期不一致的行为，导致错误产生方法入参出参 来说明 含义 3 ：当子类的方法重载父类的方法时，方法的前置条件（既方法的入参）要比父类的入参更宽松。public class Base { public void method(HashMap hashMap) { System.out.println(\"父类被执行\"); }}public class Child extends Base { @Override public void method(HashMap hashMap) { System.out.println(\"子类 HashMap 被执行\"); } // 比父类入参更宽松，不是重写，是重载 public void method(Map map) { System.out.println(\"子类 Map 被执行\"); }}public class Test { public static void main(String[] args) { Child child = new Child(); HashMap hashMap = new HashMap&lt;&gt;(); child.method(hashMap); }}输出子类 HashMap 被执行当注释掉重写方法时，输出为 父类被执行;public class Child extends Base { // @Override // public void method(HashMap hashMap) { // System.out.println(\"子类 HashMap 被执行\"); // } // 比父类入参更宽松，不是重写，是重载 public void method(Map map) { System.out.println(\"子类 Map 被执行\"); }}这个结果是正确的，那么反过来，将父类替换成public class Base { public void method(Map hashMap) { System.out.println(\"父类被执行\"); }}public class Child extends Base { // 重载：子类的前置条件比父类严格 public void method(HashMap hashMap) { System.out.println(\"子类 HashMap 被执行\"); }}public class Test { public static void main(String[] args) { Child child = new Child(); HashMap hashMap = new HashMap&lt;&gt;(); child.method(hashMap); }}将会输出： 子类 HashMap 被执行这就破坏了里氏替换原则，因为这样执行，不是父类的被执行了，容易引起业务逻辑的混乱。bug容易产生。在写这个简单的例子的时候，就很容易被搞懵逼；后置条件，也就是返回参数 含义 4 ：当子类的方法实现父类的方法时（重写/重载或实现抽象方法）方法的后置条件（及方法的返回值）要比如雷更严格或相等。在 java 中重写适合返回参数无关的，像下面这个例子，在 Idea 中就提示错误了，所以这样的情况一般比较少犯错误，如果不写 override，那么就容易产生混乱。// 父类是 HashMap@Overridepublic Map method() {}实际上看来，这里的例子是在讲，多态，重写，重载，相似的新方法，容易产生逻辑混乱调用，不容易发现问题。 如果遵守里氏替换原则的写法，能减少这样的情况。维护性还有就是里氏替换原则的约束继承泛滥的问题。这一个原则理解起来感觉有点难，懵逼开闭原则定义：一个软件实体如类，模块和函数应该对扩展开放，对修改关闭开闭，是对扩展和修改两个行为的描述强调的是：用抽象构建框架，用实现扩展细节优点：提高软件系统的可复用性及可维护性在生活中有一个例子体现：每天工作 8 小时，8 小时是关闭的，什么时候来？什么时候走？这个是开放的开闭原则的核心：面向抽象编程，抽象相对来说是稳定的，对修改关闭；如：一个校验逻辑，先校验什么，后校验什么。扩展一个校验，也就是功能增强，而不要去修改已有的校验功能，这是对修改关闭开闭原则 coding一个场景：慕课网的课程表述；/** * 课程 * @author : zhuqiang * @version : V1.0 * @date : 2018/8/23 23:38 */public interface ICourse { Integer getId(); String getName(); Double getPrice();}package cn.mrcode.newstudy.design.pattern.principle.openclose;/** * java 类课程;还有js，算法等课程，需要分开 * @author : zhuqiang * @version : V1.0 * @date : 2018/8/23 23:40 */public class JavaCourse implements ICourse { private Integer id; private String name; private Double price; public JavaCourse(Integer id, String name, Double price) { this.id = id; this.name = name; this.price = price; } @Override public Integer getId() { return this.id; } @Override public String getName() { return this.name; } @Override public Double getPrice() { return this.price; }}public class Test { public static void main(String[] args) { JavaCourse javaCourse = new JavaCourse(96, \"设计模式\", 389d); System.out.println(\"ID:\" + javaCourse.getId() + \"，课程名称：\" + javaCourse.getName() + \"，价格：\" + javaCourse.getPrice()); }}注意看现在的类图结构：JavaCourse 继承了 ICourse （实心箭头）输出如下ID:96，课程名称：设计模式，价格：389.0需求2：双11到了，搞活动，打8折那么方案有以下几种，都能满足需求，来说说不足的地方 直接在输出的地方价格乘以 0.8 如果只是某些课程打折呢？ 在 JavaCourse 类中 getPrice 方法中乘以 0.8 如果要获取原价呢? 如果还有要求说是价格大于300的课程才打折呢？ 在 ICourse 接口中增加打折方法：discountCourse 如果有很多课程，那么影响范围巨大，除非一开始就已经定义了这种接口 一看业务变化，上面的方案对于维护来说都是个不好的办法，那么应该怎么办呢？开闭原则：模块和函数应该对扩展开放，对修改关闭那么增加一个打折的子类即可；package cn.mrcode.newstudy.design.pattern.principle.openclose;/** * java课程打折 * @author : zhuqiang * @version : V1.0 * @date : 2018/8/24 0:13 */public class JavaDiscountCourse extends JavaCourse { public JavaDiscountCourse(Integer id, String name, Double price) { super(id, name, price); } @Override public Double getPrice() { // 这里可以针对业务进行范围的判定等操作 return super.getPrice() * 0.8; } /** 获取原价 */ public Double getOriginPrice() { return super.getPrice(); }}public static void main(String[] args) { ICourse iCourse = new JavaDiscountCourse(96, \"设计模式\", 389d); JavaDiscountCourse javaCourse = (JavaDiscountCourse) iCourse; System.out.println(\"ID:\" + javaCourse.getId() + \"，课程名称：\" + javaCourse.getName() + \"，价格：\" + javaCourse.getPrice() + \", 原价：\" + javaCourse.getOriginPrice() );}输出如下：ID:96，课程名称：设计模式，价格：311.20000000000005, 原价：389.0看现在的类图：这里没有严格按照我们之前讲解的图形来演示，而是有颜色和标识，反正差别不大，更容易看明白主要是这里的类图结构和增强之前的类图结构对比；阐述了开闭原则，而对于上面所说的那些维护问题相对来说也更方便维护，结构上也更容易理解（杠精请绕道，一般的web开发，基本上不会这样做）单一职责原则定义：不要存在多于一个导致类变更的原因理解：比如：一个类负责了 2 个功能，在修改功能 1 时，导致功能 2 发生了故障；两个功能在需求变更的时候都有可能导致类变更，那么该类存在两个导致类变更的原因体现： 一个类、接口、方法只负责一项职责优点： 降低类的复杂度 提高类的可读性 提高系统的可维护性 降低变更引起的风险 变更是必然的，单一职责原则遵循的好，可以降低变更引起的风险 单一职责也适用于模块化设计 开始coding基本场景场景：鸟的动作public class Bird { // 主要移动方式 public void mainMoveMode(String birdName) { System.out.println(birdName + \"用翅膀飞\"); }}public class Test { public static void main(String[] args) { Bird bird = new Bird(); bird.mainMoveMode(\"大雁\"); bird.mainMoveMode(\"鸵鸟\"); }}大雁用翅膀飞鸵鸟用翅膀飞这里的结果就有问题了：鸵鸟主要移动方式是用脚走路。那么进行修改public class Bird { public void mainMoveMode(String birdName) { if (\"鸵鸟\".equals(birdName)) { System.out.println(birdName + \"用脚走\"); } else { System.out.println(birdName + \"用翅膀飞\"); } }}这个示例说实在的，我自己平时在开发的时候就经常这样做，这样做的原因有多种，比如 时间关系 感觉这个业务不怎么复杂，这样改动是最方便最快捷的如果还有更多的不同移动方式的鸟类呢？这里的逻辑则会更多的判定。如果在一段很复杂的业务逻辑中，就很容易出错。这里就破坏了单一职责原则-降低变更引起的风险类单一职责演示把上面负责多职责的拆分成单一职责// 会飞的鸟public class FlyBird { public void mainMoveMode(String birdName) { System.out.println(birdName + \"用翅膀飞\"); }}// 用脚走的鸟public class WalkBird { public void mainMoveMode(String birdName) { System.out.println(birdName + \"用脚走\"); }}由应用层来判定，什么鸟适合什么行走方式FlyBird flyBird = new FlyBird();flyBird.mainMoveMode(\"大雁\");WalkBird walkBird = new WalkBird();walkBird.mainMoveMode(\"鸵鸟\");接口级别public interface ICourse { // ~----------- 课程信息 String getCourseName(); byte[] getCourseVideo(); // ~----------- 课程管理 /** 学习课程 */ void studyCourrse(); /** 退款这门课程 */ void refundCourse();}对于这个接口来说，有两个大的职责：获取课程信息和课程管理。如果当课程被退掉的时候，这门课程的信息就获取不到了，也就是说 refundCourse 会影响获取课程信息相关的功能。public interface ICourseContent { // ~----------- 课程信息 String getCourseName(); byte[] getCourseVideo();}public interface ICourseManager { // ~----------- 课程管理 /** 学习课程 */ void studyCourrse(); /** 退款这门课程 */ void refundCourse();}public class CourseImpl implements ICourseContent, ICourseManager { @Override public String getCourseName() { return null; } @Override public byte[] getCourseVideo() { return new byte[0]; } @Override public void studyCourrse() { } @Override public void refundCourse() { }}由具体的实现选择来组合实现哪些功能（也可以只实现其中一个）， 在接口级别上两个接口的职责是清晰的，隔离的。 复杂度也降低了，可读性也变高了 降低变更引起的风险，可维护性变高了 一个接口的修改不影响另一个接口的功能方法级别public void updateUserInfo(String userName, String address, boolean bool) { if (bool) { // 逻辑1 } else { // 逻辑2 }}这种的逻辑，很明确的是两个功能逻辑，就可以完全拆分成两个方法来处理这不同的功能，而不是用一个标志来处理"
    } ,
  
    {
      "title"       : "设计模式二:外观模式",
      "category"    : "",
      "tags"        : "设计模式",
      "url"         : "./%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.html",
      "date"        : "2022-05-19 03:32:20 +0800",
      "description" : "外观模式",
      "content"     : "初识外观模式定义：为子系统中一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用结构和说明：界面：从客户端来看待这个系统，能看到的东西Facade ： 定义子系统的多个模块对外的高层接口，通常需要调用内部多个模块，从而把客户的请求代理给适当的子系统对象。模块：接收Facade对象的委派，真正实现功能，各个模块之间可能有交互。☂注意：Facade对象知道各个模块，但是各个模块不应该知道Facade对象体会外观模式生活中的示列：组装电脑 完全自己组装 找专业装机公司组装 工具示例：代码生成工具问题：如果现在客户端需要使用这个代码生成工具来生成需要的基础代码，该如何来实现呢？不用模式解决方案存在的问题：客户端为了使用生成代码的功能，需要与生成代码子系统内部的多个模块交互使用模式解决方案public interface AModuleApi { void test();}public class AModuleImpl implements AModuleApi{ @Override public void test() { System.out.println(\"模块a\"); }}public interface BModuleApi { void test();}public class BModuleImpl implements AModuleApi{ @Override public void test() { System.out.println(\"模块b\"); }}public interface CModuleApi { void test();}public class CModuleImpl implements AModuleApi{ @Override public void test() { System.out.println(\"模块\"); }}public class Facade { /** * 满足客户端需要的方法 */ public void test(){ // 内部实现的时候，可能会调用各个模块 // 如果遇到这样一种情况，需要按顺序调用这3个方法，那么在客户端使用的时候还需要搞懂先调用什么后调用什么，就很不方便了，所以使用外观模式封装起来 new AModuleImpl().test(); new BModuleImpl().test(); new CModuleImpl().test(); }}public class Client { public static void main(String[] args) { // 这里使用外观模式，就不再需要客户端与各个模块直接打交道了 new Facade().test(); }}理解外观模式认识外观模式 外观模式的目的不是给子系统添加新的功能接口，而是为了让外部减少与子系统内多个模块的交互，松散耦合，从而让外部能够更简单的使用子系统。不能在外观模式的接口或则类中直接实现客户端的功能。应该是包装组合已有的功能，来满足客户端的需求 使用外观跟不使用外观有何变化？Facade方便了客户端的调用、封装了系统内部的细节功能、实现功能的共享和复用重点在于Facade的位置，Facade属于红框中的一部分。所以facade是可以知道具体实现的。 而客户端确是不知道的 有外观，但是可以不使用 外观提供了缺省的调用（对常用的进行一些包装，如果有特殊的需求，就使用第三点，直接调用具体的实现） 外观模式的调用顺序示意图 外观模式的实现 把外观类当成一个辅助工具类实现 facade可以实现为interface Facade实现称为interface的附带好处能够有选择性的暴露接口方法，尽量减少模块对 外提供的接口方法。 Facade的方法实现Facade的方法实现中，一般是负责把客户端的请求转发给子系统内部的各个模块进行处理，Facade的方法本身并不进行功能的处理，Facade的方法的实现只是实现一个功能的组合调用"
    } ,
  
    {
      "title"       : "设计模式一:初识简单工厂模式",
      "category"    : "",
      "tags"        : "设计模式",
      "url"         : "./%E5%88%9D%E8%AF%86%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html",
      "date"        : "2022-05-19 03:32:20 +0800",
      "description" : "简单工厂模式",
      "content"     : "初识简单工厂定义提供一个创建对象实例的功能，而无需关心其具体实现。被构建实例的类型可以是接口、抽象类，也可以是具体的类结构和说明![]/assets/img/posts/20220518/design_pattern/simple_factory/img/posts/20220518/design_pattern/simple_factory/1.jpg)APi： 定义客户所需要的功能接口Impl： 具体实现Api的实现类，可能会有多个Factory： 工厂，选择合适的实现类来创建Api的接口对象Client： 客户端，通过Factory去获取Api接口对象，然后面向Api接口编程public interface Api { void operation(String s);}public class ImplA implements Api { @Override public void operation(String s) { System.out.println(\"实现a:\" + s); }}public class ImplB implements Api { @Override public void operation(String s) { System.out.println(\"实现b:\" + s); }}public class Factory { public static Api createApi(int condition){ if(condition == 1){ return new ImplA(); }else if(condition == 2) { return new ImplB(); } return null; }}public class Client { public static void main(String[] args) { Api api = Factory.createApi(1); api.operation(\"hello\"); api = Factory.createApi(2); api.operation(\"hello\"); }}接口回顾： Java 中接口的概念：在 Java 中接口是一种特殊的抽象类 接口用来干什么: 通常用接口来定义实现类的外观，就相当于一份契约，根据外部应用需要的功能，约定了实现类应该要实现的功能 接口的思想： 封装隔离 使用接口的好处 只要接口不变，内部实现的变化就不会影响到外部应用，从而使得系统更灵活，具有更好的扩展性和可维护性 接口和抽象类的选择 （1）：优先选用接口 （2）：在如下情况选抽象类：既要定义子类的行为，又要为子类提供公共的功能 面向接口编程回顾：面向接口编程是 Java 编程中的一个重要原则。在 Java 程序设计里面，非常讲究层的划分和模块的划分。比如常见的三层结构在一个层内部的各个模块交互也要通过接口不管是一层还是一个模块或则一个组件，都是一个被接口隔离的整体体会简单工厂不用模式的解决方案public interface Api { void test(String s);}public class Impl implements Api { @Override public void test(String s) { System.out.println(\"不用模式的解决方案:\" + s); }}public class Client { public static void main(String[] args) { Api api = new Impl(); api.test(\"hello\"); }}用模式的解决方案参考上面的 结构和说明 中的代码理解简单工厂一个典型的疑问首先来解决一个常见的疑问： 可能有朋友会认为，上面的示列中的简单工厂看起来不就是把客户端里面的 new Impl() 移动到简单工厂里面吗？不还是一样通过 new 实现类来得到接口吗？ 把 new Impl() 这句话放到客户端和放到简单工厂里面有什么不同吗？理解这个问题的重点就在于理解简单工厂所处的位置。红框代表一个封装体，完全在红框中的为封装体内部的，工厂和接口暴露了一部分给外部。认识简单工厂 简单工厂的功能 可以用来创建接口、抽象类或则是普通类的实例 静态工厂 通常把简单工厂类实现成一个工具类，直接使用静态方法就可以了，也就是说简单工厂的方法通常都是静态的，所以也被称为静态工厂 万能工厂 一个简单工厂理论上可以用来构造任何对象，所以又称之为“万能工厂” 简单工厂创建对象的范围 建议控制在一个独立的组件级别或则一个模块级别 简单工厂的调用顺序示意图 简单工厂命名的建议 类名建议为：“模块名称 + Factory ” 方法名通常为：“ get + 接口名称”或则是“ create + 接口名称” 不建议把方法名称命名为 new + 接口名称 简单工厂中方法的写法简单工方法的内部主要实现的功能是“选择合适的实现类”来创建实例对象选择 –&gt; 如何选? —&gt; 选择的参数 –&gt; 参数从何而来？ 参数来源于client 参数来源于配置文件 参数来源于系统自身，比如运行期间的某个值注：如果是从客户端在调用工厂的时候，传入选择的参数，这就说明客户端必须知道每个参数的含义，也需要理解每个参数对应的功能处理。这就要求必须在一定程度上，向客户暴露一定的内部实现细节。可配置的简单工厂使用反射加上配置文件，来实现添加新的实现类过后，无需修改代码，就能把这个新的实现类加入应用中。可配置的简单工厂，也是通过选择，但是这个选择不是体现在方法中了。 而是通过配置文件这里配置是配置一些参数，用于选择哪一个实现。简单工厂的优缺点：优点： 帮助封装： 真正实现面向接口编程 解耦：客户端和具体实现可以解耦缺点： 可能增加客户端的复杂度：需要调用接口，就得了解这些参数的含义 不方便扩展子工程思考简单工厂简单工厂的本质简单工厂的本质是： 选择实现 重点是选择何时选用简单工厂： 如果想要完全封装隔离具体实现，让外部只能通过接口来操作封装体，那么可以选用简单工厂，让客户端通过工厂来获取相应的接口，而无需关心具体实现。 如果想要把对外创建对象的职责集中管理和控制，可以选用简单工厂，一个简单工厂可以创建很多的、不相关的对象，可以把对外创建对象的职责集中到一个简单工厂来，从而实现集中管理和控制"
    } ,
  
    {
      "title"       : "单点登录机制",
      "category"    : "",
      "tags"        : "JAVA技术框架",
      "url"         : "./%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%9C%BA%E5%88%B6.html",
      "date"        : "2022-05-17 03:32:20 +0800",
      "description" : "单点登录详解",
      "content"     : "什么是单点登录简称为 SSO，SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。单点登录基本流程如下：1）当用户第一次访问应用系统的时候，因为还没有登录，会被引导到认证系统中进行登录；2）根据用户提供的登录信息，认证系统进行身份校验，如果通过校验，应该返回给用户一个认证的凭据－－ticket；3）用户再访问别的应用的时候，就会将这个ticket带上，作为自己认证的凭据，应用系统接受到请求之后会把ticket送到认证系统进行校验，检查ticket的合法性。如果通过校验，用户就可以在不用再次登录的情况下访问应用系统2和应用系统3了。普通的登录认证机制如上图所示，我们在浏览器（Browser）中访问一个应用，这个应用需要登录，我们填写完用户名和密码后，完成登录认证。这时，我们在这个用户的session中标记登录状态为yes（已登录），同时在浏览器（Browser）中写入Cookie，这个Cookie是这个用户的唯一标识。下次我们再访问这个应用的时候，请求中会带上这个Cookie，服务端会根据这个Cookie找到对应的session，通过session来判断这个用户是否登录。如果不做特殊配置，这个Cookie的名字叫做jsessionid，值在服务端（server）是唯一的。 Cookie　　Cookie技术是http状态保持在客户端的解决方案，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。 Cookie的内容、作用域以及有效期　　cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域合在一起就构成了cookie的作用范围。如果不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了，这种生命期为浏览器会话期的 cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里。如果设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。 Session　　Session一般叫做回话，Session技术是http状态保持在服务端的解决方案，它是通过服务器来保持状态的。我们可以把客户端浏览器与服务器之间一系列交互的动作称为一个 Session。是服务器端为客户端所开辟的存储空间，在其中保存的信息就是用于保持状态。因此，session是解决http协议无状态问题的服务端解决方案，它能让客户端和服务端一系列交互动作变成一个完整的事务。 Session的创建　　那么Session在何时创建呢？当然还是在服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同创建Session的方法。当客户端第一次请求服务端，当server端程序调用HttpServletRequest.getSession(true)这样的语句时的时候，服务器会为客户端创建一个session，并将通过特殊算法算出一个session的ID，用来标识该session对象。　　Session存储在服务器的内存中(tomcat服务器通过StandardManager类将session存储在内存中)，也可以持久化到file，数据库，memcache，redis等。客户端只保存sessionid到cookie中，而不会保存session。　　浏览器的关闭并不会导致Session的删除，只有当超时、程序调用HttpSession.invalidate()以及服务端程序关闭才会删除。 Cookie与Session的关系　　cookie和session的方案虽然分别属于客户端和服务端，但是服务端的session的实现对客户端的cookie有依赖关系的，服务端执行session机制时候会生成session的id值，这个id值会发送给客户端，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，而这个id值在客户端会保存下来，保存的容器就是cookie，因此当我们完全禁掉浏览器的cookie的时候，服务端的session也会不能正常使用。 同域单点登录一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com和app2.a.com。我们要做单点登录（SSO），需要一个登录系统，叫做：sso.a.com。我们只要在sso.a.com登录，app1.a.com和app2.a.com就也登录了。通过上面的登陆认证机制，我们可以知道，在sso.a.com中登录了，其实是在sso.a.com的服务端的session中记录了登录状态，同时在浏览器端（Browser）的sso.a.com下写入了Cookie。那么我们怎么才能让app1.a.com和app2.a.com登录呢？这里有两个问题：Cookie是不能跨域的，我们Cookie的domain属性是sso.a.com，在给app1.a.com和app2.a.com发送请求是带不上的。sso、app1和app2是不同的应用，它们的session存在自己的应用内，是不共享的。那么我们如何解决这两个问题呢？针对第一个问题，sso登录以后，可以将Cookie的域设置为顶域，即.a.com，这样所有子域的系统都可以访问到顶域的Cookie。我们在设置Cookie时，只能设置顶域和自己的域，不能设置其他的域。比如：我们不能在自己的系统中给baidu.com的域设置Cookie。Cookie的问题解决了，我们就需要来看看session的问题。我们在sso系统登录了，这时再访问app1，Cookie也带到了app1的服务端（Server），app1的服务端怎么找到这个Cookie对应的Session呢？这里就要把3个系统的Session共享，如图所示。共享Session的解决方案有很多，例如：Spring-Session。这样第2个问题也解决了。"
    } 
  
]
