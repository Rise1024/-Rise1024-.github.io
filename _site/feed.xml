<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-05-20T10:18:23+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Rise小破站</title><subtitle>Rise1024的小破站</subtitle><author><name>Rise1024</name></author><entry><title type="html">设计模式一:初识简单工厂模式</title><link href="http://localhost:4000/%E5%88%9D%E8%AF%86%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html" rel="alternate" type="text/html" title="设计模式一:初识简单工厂模式" /><published>2022-05-19T03:32:20+08:00</published><updated>2022-05-19T03:32:20+08:00</updated><id>http://localhost:4000/%E5%88%9D%E8%AF%86%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F</id><content type="html" xml:base="http://localhost:4000/%E5%88%9D%E8%AF%86%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html"><![CDATA[<h2 id="初识简单工厂">初识简单工厂</h2>

<h3 id="定义">定义</h3>

<p>提供一个创建对象实例的功能，而无需关心其具体实现。被构建实例的类型可以是接口、抽象类，也可以是具体的类</p>

<h3 id="结构和说明">结构和说明</h3>

<p><img src="/assets/img/posts/20220518/design_pattern/simple_factory/1.jpg" alt="" /></p>

<p><strong>APi：</strong> 定义客户所需要的功能接口</p>

<p><strong>Impl：</strong> 具体实现Api的实现类，可能会有多个</p>

<p><strong>Factory：</strong> 工厂，选择合适的实现类来创建Api的接口对象</p>

<p><strong>Client：</strong> 客户端，通过Factory去获取Api接口对象，然后面向Api接口编程</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Api</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">operation</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ImplA</span> <span class="kd">implements</span> <span class="nc">Api</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">operation</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"实现a:"</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ImplB</span> <span class="kd">implements</span> <span class="nc">Api</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">operation</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"实现b:"</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Factory</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Api</span> <span class="nf">createApi</span><span class="o">(</span><span class="kt">int</span> <span class="n">condition</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">condition</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">ImplA</span><span class="o">();</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">condition</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">ImplB</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Client</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Api</span> <span class="n">api</span> <span class="o">=</span> <span class="nc">Factory</span><span class="o">.</span><span class="na">createApi</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">api</span><span class="o">.</span><span class="na">operation</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
        <span class="n">api</span> <span class="o">=</span> <span class="nc">Factory</span><span class="o">.</span><span class="na">createApi</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">api</span><span class="o">.</span><span class="na">operation</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h3 id="接口回顾">接口回顾：</h3>

<ol>
  <li>
    <p>Java 中接口的概念：在 Java 中接口是一种特殊的抽象类</p>
  </li>
  <li>
    <p>接口用来干什么:</p>

    <p>通常用接口来定义实现类的外观，就相当于一份契约，根据外部应用需要的功能，约定了实现类应该要实现的功能</p>
  </li>
  <li>
    <p>接口的思想： 封装隔离</p>
  </li>
  <li>
    <p>使用接口的好处</p>

    <p>只要接口不变，内部实现的变化就不会影响到外部应用，从而使得系统更灵活，具有更好的扩展性和可维护性</p>
  </li>
  <li>
    <p>接口和抽象类的选择</p>

    <p>（1）：优先选用接口</p>

    <p>（2）：在如下情况选抽象类：既要定义子类的行为，又要为子类提供公共的功能</p>
  </li>
</ol>

<h3 id="面向接口编程回顾">面向接口编程回顾：</h3>

<p>面向接口编程是 Java 编程中的一个重要原则。在 Java 程序设计里面，非常讲究层的划分和模块的划分。</p>

<p>比如常见的三层结构
在一个层内部的各个模块交互也要通过接口
不管是一层还是一个模块或则一个组件，都是一个被接口隔离的整体</p>

<hr />

<h2 id="体会简单工厂">体会简单工厂</h2>

<h3 id="不用模式的解决方案">不用模式的解决方案</h3>

<p><img src="/assets/img/posts/20220518/design_pattern/simple_factory/2.jpg" alt="" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Api</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Impl</span> <span class="kd">implements</span> <span class="nc">Api</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"不用模式的解决方案:"</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Client</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Api</span> <span class="n">api</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Impl</span><span class="o">();</span>
        <span class="n">api</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="用模式的解决方案">用模式的解决方案</h3>
<p>参考上面的 <strong>结构和说明</strong> 中的代码</p>

<hr />

<h2 id="理解简单工厂">理解简单工厂</h2>

<h3 id="一个典型的疑问">一个典型的疑问</h3>

<p><strong>首先来解决一个常见的疑问：</strong> 可能有朋友会认为，上面的示列中的简单工厂看起来不就是把客户端里面的 <code class="language-plaintext highlighter-rouge">new Impl()</code> 移动到简单工厂里面吗？不还是一样通过 new  实现类来得到接口吗？  把 <code class="language-plaintext highlighter-rouge">new Impl()</code> 这句话放到客户端和放到简单工厂里面有什么不同吗？</p>

<p><code class="language-plaintext highlighter-rouge">理解这个问题的重点就在于理解简单工厂所处的位置。</code></p>

<p><img src="/assets/img/posts/20220518/design_pattern/simple_factory/3.jpg" alt="" /></p>

<p>红框代表一个封装体，完全在红框中的为封装体内部的，工厂和接口暴露了一部分给外部。</p>

<h3 id="认识简单工厂">认识简单工厂</h3>

<ol>
  <li>
    <p>简单工厂的功能</p>

    <p>可以用来创建接口、抽象类或则是普通类的实例</p>
  </li>
  <li>
    <p>静态工厂</p>

    <p>通常把简单工厂类实现成一个工具类，直接使用静态方法就可以了，也就是说简单工厂的方法通常都是静态的，所以也被称为静态工厂</p>
  </li>
  <li>
    <p>万能工厂</p>

    <p>一个简单工厂理论上可以用来构造任何对象，所以又称之为“万能工厂”</p>
  </li>
  <li>
    <p>简单工厂创建对象的范围</p>

    <p>建议控制在一个独立的组件级别或则一个模块级别</p>
  </li>
  <li>
    <p>简单工厂的调用顺序示意图</p>
  </li>
</ol>

<p><img src="/assets/img/posts/20220518/design_pattern/simple_factory/4.jpg" alt="" /></p>

<ol>
  <li>
    <p>简单工厂命名的建议</p>

    <ol>
      <li>类名建议为：“模块名称 + Factory ”</li>
      <li>方法名通常为：“ get + 接口名称”或则是“ create + 接口名称”</li>
      <li>不建议把方法名称命名为 new + 接口名称</li>
    </ol>
  </li>
</ol>

<h3 id="简单工厂中方法的写法">简单工厂中方法的写法</h3>

<p>简单工方法的内部主要实现的功能是“选择合适的实现类”来创建实例对象</p>

<p>选择 –&gt; 如何选? —&gt; 选择的参数 –&gt; 参数从何而来？</p>

<ol>
  <li>参数来源于client</li>
  <li>参数来源于配置文件</li>
  <li>参数来源于系统自身，比如运行期间的某个值</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">注：</code>如果是从客户端在调用工厂的时候，传入选择的参数，这就说明客户端必须知道每个参数的含义，也需要理解每个参数对应的功能处理。这就要求必须在一定程度上，向客户暴露一定的内部实现细节。</p>

<h3 id="可配置的简单工厂">可配置的简单工厂</h3>

<p>使用反射加上配置文件，来实现添加新的实现类过后，无需修改代码，就能把这个新的实现类加入应用中。</p>

<p>可配置的简单工厂，也是通过选择，但是这个选择不是体现在方法中了。 而是通过配置文件</p>

<p>这里配置是配置一些参数，用于选择哪一个实现。</p>

<h3 id="简单工厂的优缺点">简单工厂的优缺点：</h3>

<p><strong>优点：</strong></p>

<ol>
  <li>帮助封装： 真正实现面向接口编程</li>
  <li>解耦：客户端和具体实现可以解耦</li>
</ol>

<p><strong>缺点：</strong></p>

<ol>
  <li>可能增加客户端的复杂度：需要调用接口，就得了解这些参数的含义</li>
  <li>不方便扩展子工程</li>
</ol>

<hr />

<h2 id="思考简单工厂">思考简单工厂</h2>

<h3 id="简单工厂的本质">简单工厂的本质</h3>

<p>简单工厂的本质是： 选择实现 <strong>重点是选择</strong></p>

<h3 id="何时选用简单工厂">何时选用简单工厂：</h3>

<ol>
  <li>
    <p>如果想要完全封装隔离具体实现，让外部只能通过接口来操作封装体，那么可以选用简单工厂，让客户端通过工厂来获取相应的接口，而无需关心具体实现。</p>
  </li>
  <li>
    <p>如果想要把对外创建对象的职责集中管理和控制，可以选用简单工厂，一个简单工厂可以创建很多的、不相关的对象，可以把对外创建对象的职责集中到一个简单工厂来，从而实现集中管理和控制</p>
  </li>
</ol>]]></content><author><name>Rise1024</name></author><category term="设计模式" /><summary type="html"><![CDATA[简单工厂模式]]></summary></entry><entry><title type="html">设计模式二:外观模式</title><link href="http://localhost:4000/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.html" rel="alternate" type="text/html" title="设计模式二:外观模式" /><published>2022-05-19T03:32:20+08:00</published><updated>2022-05-19T03:32:20+08:00</updated><id>http://localhost:4000/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F</id><content type="html" xml:base="http://localhost:4000/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.html"><![CDATA[<h2 id="初识外观模式">初识外观模式</h2>
<h3 id="定义">定义：</h3>
<p>为子系统中<code class="language-plaintext highlighter-rouge">一组接口</code>提供一个<code class="language-plaintext highlighter-rouge">一致的界面</code>，Facade模式定义了<code class="language-plaintext highlighter-rouge">一个高层接口</code>，这个接口使得这一子系统<code class="language-plaintext highlighter-rouge">更加容易使用</code></p>

<h3 id="结构和说明">结构和说明：</h3>
<p><img src="/assets/img/posts/20220518/design_pattern/facade/1.jpg" alt="" /></p>

<p><strong>界面：</strong>从客户端来看待这个系统，能看到的东西
<strong>Facade ：</strong> 定义子系统的多个模块对外的高层接口，通常需要调用内部多个模块，从而<code class="language-plaintext highlighter-rouge">把客户的请求代理给适当的子系统对象</code>。
<strong>模块：</strong>接收Facade对象的委派，真正实现功能，各个模块之间可能有交互。<code class="language-plaintext highlighter-rouge">☂注意：</code>Facade对象知道各个模块，但是各个模块不应该知道Facade对象</p>

<hr />

<h2 id="体会外观模式">体会外观模式</h2>
<h3 id="生活中的示列组装电脑">生活中的示列：组装电脑</h3>
<ol>
  <li>
    <p>完全自己组装
<img src="/assets/img/posts/20220518/design_pattern/facade/2.jpg" alt="" /></p>
  </li>
  <li>
    <p>找专业装机公司组装
<img src="/assets/img/posts/20220518/design_pattern/facade/3.jpg" alt="" /></p>
  </li>
</ol>

<h3 id="工具示例代码生成工具">工具示例：代码生成工具</h3>
<p><img src="/assets/img/posts/20220518/design_pattern/facade/4.jpg" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">问题：</code>如果现在客户端需要使用这个代码生成工具来生成需要的基础代码，该如何来实现呢？</p>

<h3 id="不用模式解决方案">不用模式解决方案</h3>

<p><img src="/assets/img/posts/20220518/design_pattern/facade/5.jpg" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">存在的问题：</code>客户端为了使用生成代码的功能，需要与生成代码子系统内部的多个模块交互</p>

<h3 id="使用模式解决方案">使用模式解决方案</h3>
<p><img src="/assets/img/posts/20220518/design_pattern/facade/6.jpg" alt="" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AModuleApi</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AModuleImpl</span> <span class="kd">implements</span> <span class="nc">AModuleApi</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"模块a"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">BModuleApi</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BModuleImpl</span> <span class="kd">implements</span> <span class="nc">AModuleApi</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"模块b"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">CModuleApi</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CModuleImpl</span> <span class="kd">implements</span> <span class="nc">AModuleApi</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"模块"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Facade</span> <span class="o">{</span>
    <span class="cm">/**
     * 满足客户端需要的方法
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(){</span>
        <span class="c1">// 内部实现的时候，可能会调用各个模块</span>
		<span class="c1">// 如果遇到这样一种情况，需要按顺序调用这3个方法，那么在客户端使用的时候还需要搞懂先调用什么后调用什么，就很不方便了，所以使用外观模式封装起来</span>
        <span class="k">new</span> <span class="nf">AModuleImpl</span><span class="o">().</span><span class="na">test</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">BModuleImpl</span><span class="o">().</span><span class="na">test</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">CModuleImpl</span><span class="o">().</span><span class="na">test</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Client</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 这里使用外观模式，就不再需要客户端与各个模块直接打交道了</span>
        <span class="k">new</span> <span class="nf">Facade</span><span class="o">().</span><span class="na">test</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="理解外观模式">理解外观模式</h2>
<h3 id="认识外观模式">认识外观模式</h3>
<ol>
  <li>
    <p>外观模式的<code class="language-plaintext highlighter-rouge">目的不是给子系统添加新的功能接口</code>，<code class="language-plaintext highlighter-rouge">而是为了让外部减少与子系统内多个模块的交互，松散耦合</code>，从而让外部能够更简单的使用子系统。
<code class="language-plaintext highlighter-rouge">不能在外观模式的接口或则类中直接实现客户端的功能。应该是包装组合已有的功能</code>，来满足客户端的需求</p>
  </li>
  <li>
    <p>使用外观跟不使用外观有何变化？
Facade方便了客户端的调用、封装了系统内部的细节功能、实现功能的共享和复用
<img src="/assets/img/posts/20220518/design_pattern/facade/7.jpg" alt="" />
<code class="language-plaintext highlighter-rouge">重点在于Facade的位置</code>，Facade属于红框中的一部分。所以facade是可以知道具体实现的。 而客户端确是不知道的</p>
  </li>
  <li>
    <p>有外观，但是可以不使用</p>
  </li>
  <li>
    <p>外观提供了缺省的调用
（对常用的进行一些包装，如果有特殊的需求，就使用第三点，直接调用具体的实现）</p>
  </li>
  <li>
    <p>外观模式的调用顺序示意图
<img src="/assets/img/posts/20220518/design_pattern/facade/8.jpg" alt="" /></p>
  </li>
</ol>

<h3 id="外观模式的实现">外观模式的实现</h3>
<ol>
  <li>把外观类当成一个辅助工具类实现</li>
  <li>
    <p>facade可以实现为interface
<img src="/assets/img/posts/20220518/design_pattern/facade/9.jpg" alt="" /></p>
  </li>
  <li>Facade实现称为interface的附带好处
能够有选择性的暴露接口方法，尽量减少模块对 外提供的接口方法。</li>
  <li>Facade的方法实现
Facade的方法实现中，一般是负责把客户端的请求转发给子系统内部的各个模块进行处理，Facade的方法本身并不进行功能的处理，Facade的方法的实现只是实现一个功能的组合调用</li>
</ol>]]></content><author><name>Rise1024</name></author><category term="设计模式" /><summary type="html"><![CDATA[外观模式]]></summary></entry><entry><title type="html">7大设计原则</title><link href="http://localhost:4000/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.html" rel="alternate" type="text/html" title="7大设计原则" /><published>2022-05-19T03:32:20+08:00</published><updated>2022-05-19T03:32:20+08:00</updated><id>http://localhost:4000/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99</id><content type="html" xml:base="http://localhost:4000/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.html"><![CDATA[<h2 id="合成复用原则">合成复用原则</h2>

<p>合成（组合）/ 聚合复用原则</p>

<p><strong>定义</strong>：尽量使用对象组合/聚合，而不是继承关系达到软件复用的目的</p>

<ul>
  <li>聚合 has-A</li>
  <li>组合 contains-A</li>
  <li>继承 is-A</li>
</ul>

<p><strong>优点</strong>：可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少</p>

<h4 id="何时使用合成聚合继承">何时使用合成/聚合、继承</h4>

<p>聚合：大雁去群的例子；笔记本和 U 盘，笔记本没了，U 盘还能独立存在
组合：集成显卡和笔记本，显卡坏了，你电脑也不能用了，看不见，不能操作了</p>

<p>代码场景：a 类中有一个 b类的引用</p>
<ul>
  <li>聚合：除了 a 类以外，还有其他地方对 b 类的引用，就算 a 类结束了，b 还存活着</li>
  <li>组合：只有 a 类引用，那么当 a 类结束时， b 类跟着一起结束</li>
</ul>

<h4 id="coding">Coding</h4>

<p>场景：Dao 层获取数据库连接；</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DBConnection</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getConnection</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"使用 Mysql 数据库连接"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductDao</span> <span class="kd">extends</span> <span class="nc">DBConnection</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addProduct</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">connection</span> <span class="o">=</span> <span class="kd">super</span><span class="o">.</span><span class="na">getConnection</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"使用 "</span> <span class="o">+</span> <span class="n">connection</span> <span class="o">+</span> <span class="s">" 添加产品"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ProductDao</span> <span class="n">productDao</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ProductDao</span><span class="o">();</span>
        <span class="n">productDao</span><span class="o">.</span><span class="na">addProduct</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><img src="/assets/markdown-img-paste-20180826210352150.png" alt="" /></p>

<p>需求来了：增加了 Postgresql 数据库，要切换数据源怎么办？</p>

<p>在上面的示例中，可能的修改如下：</p>

<ul>
  <li>增加 PostgresqlConnection 修改 ProductDao的继承类</li>
  <li>在 DBConnection 中新增获取 PostgresqlConnection 的方法</li>
</ul>

<p>上面这样做，都破坏了开闭原则。下面使用合成/复用原则来改造</p>

<h4 id="合成复用-改造场景">合成/复用 改造场景</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">DBConnection</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">getConnection</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MysqlDBConnection</span> <span class="kd">implements</span> <span class="nc">DBConnection</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getConnection</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"使用 Mysql 数据库连接"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PostgreesqlDBConnection</span> <span class="kd">implements</span> <span class="nc">DBConnection</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getConnection</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"使用 Postgreesql 数据库连接"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductDao</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">DBConnection</span> <span class="n">dbConnection</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addProduct</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">dbConnection</span><span class="o">.</span><span class="na">getConnection</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"使用 "</span> <span class="o">+</span> <span class="n">connection</span> <span class="o">+</span> <span class="s">" 添加产品"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDbConnection</span><span class="o">(</span><span class="nc">DBConnection</span> <span class="n">dbConnection</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dbConnection</span> <span class="o">=</span> <span class="n">dbConnection</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ProductDao</span> <span class="n">productDao</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ProductDao</span><span class="o">();</span>
        <span class="n">productDao</span><span class="o">.</span><span class="na">setDbConnection</span><span class="o">(</span><span class="k">new</span> <span class="nc">MysqlDBConnection</span><span class="o">());</span>
<span class="c1">//        productDao.setDbConnection(new PostgreesqlDBConnection());</span>
        <span class="n">productDao</span><span class="o">.</span><span class="na">addProduct</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="/assets/markdown-img-paste-2018082621124512.png" alt="" /></p>

<p>组合，一对一，强依赖。符合开闭原则，也符合里氏替换原则。随意替换数据源</p>

<h2 id="迪米特原则">迪米特原则</h2>

<p><strong>定义</strong>：一个对象应该对其他对象保持最少的了解。又叫最少知道原则</p>

<p><strong>核心</strong>：尽量降低类与类之间的耦合</p>

<p><strong>优点</strong>：降低类之间的耦合</p>

<p><strong>强调</strong>：纸盒朋友交流，不和陌生人说话</p>

<p>什么是朋友？出现在成员变量、方法的输入、输出参数中的类称为朋友类，而出现在方法体内部的类不属于朋友类</p>

<h4 id="coding-1">coding</h4>

<p>场景：老板给小组长下达指令，查询在线课程数量</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Boss</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">commandCheckNumber</span><span class="o">(</span><span class="nc">TeamLeader</span> <span class="n">teamLeader</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 老板获取到所有的课程</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Course</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Course</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="c1">// 对小组长下达检查指令</span>
        <span class="n">teamLeader</span><span class="o">.</span><span class="na">checkNumber</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TeamLeader</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">checkNumber</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Course</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 假设在检查逻辑</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"在线课程数量是："</span> <span class="o">+</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Course</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Boss</span> <span class="n">boss</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Boss</span><span class="o">();</span>
        <span class="nc">TeamLeader</span> <span class="n">teamLeader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TeamLeader</span><span class="o">();</span>
        <span class="n">boss</span><span class="o">.</span><span class="na">commandCheckNumber</span><span class="o">(</span><span class="n">teamLeader</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>在线课程数量是：20
</code></pre></div></div>

<p><img src="/assets/markdown-img-paste-2018082614551049.png" alt="" /></p>

<p>对于这个场景来说，boss 是不需要知道 Course 的，只要给 TeamLeader 下达指令，然后 TeamLeader 报告结果即可。</p>

<p>哪些是 Boss 的朋友？ TeamLeader （入参）</p>

<p>哪些不是 Boss 的朋友？ Course，既不是成员变量、方法的输入、输出参数，而只是方法体内部的类。</p>

<h4 id="迪米特原则改造">迪米特原则改造</h4>

<p><img src="/assets/markdown-img-paste-2018082614593442.png" alt="" /></p>

<p>只是把非朋友类逻辑移动到 TeamLeader 中了。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TeamLeader</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">checkNumber</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 老板获取到所有的课程</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Course</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Course</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"在线课程数量是："</span> <span class="o">+</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这里对于 TeamLeader 来说，Course 貌似又不是它的朋友了，但是这个是属于 TeamLeader 的职责</p>

<h2 id="依赖倒置原则">依赖倒置原则</h2>

<p><strong>定义</strong>：高层模块（指应用模块）不应该依赖底层模块，二者都应该依赖其抽象</p>

<ul>
  <li>抽象不应该依赖细节；细节应该依赖抽象</li>
  <li>针对接口编程，不要针对实现编程</li>
</ul>

<p>核心思想：面向接口编程</p>

<p><strong>优点</strong>：</p>

<ul>
  <li>减少类之间的耦合性</li>
  <li>提高系统稳定性</li>
  <li>提高代码可读性和维护性</li>
  <li>可降低修改程序锁造成的风险</li>
</ul>

<h4 id="coding-2">coding</h4>

<p>场景：Geely 在慕课上学习课程，学习 Java 课程，学习前端课程。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">cn.mrcode.newstudy.design.pattern.principle.dependencyinversion</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Geely</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">studyJavaCourse</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Geely 在学习 Java 课程"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">studyFECourse</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Geely 在学习 FE 课程"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">cn.mrcode.newstudy.design.pattern.principle.dependencyinversion</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Geely</span> <span class="n">geely</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Geely</span><span class="o">();</span>
        <span class="n">geely</span><span class="o">.</span><span class="na">studyJavaCourse</span><span class="o">();</span>
        <span class="n">geely</span><span class="o">.</span><span class="na">studyFECourse</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Geely 在学习 Java 课程
Geely 在学习 FE 课程
</code></pre></div></div>

<p>现在的问题是：如果要再增加一门学习课程呢？那么解决的方案只能在 Geely 类中增加另外一门课程的方法，然后Test（应用层）再调用该方法</p>

<p>这破坏了_依赖倒置原则_，Test(应用层)依赖Geely（底层模块）。下面使用依赖倒置原则来进行修改</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public interface ICourse {
    void studyCourse();
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class JavaCourse implements ICourse {
    @Override
    public void studyCourse() {
        System.out.println("Geely 在学习 Java 课程");
    }
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class FECourse implements ICourse {
    @Override
    public void studyCourse() {
        System.out.println("Geely 在学习 FE 课程");
    }
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Geely {
    public void studyImoocCourse(ICourse iCourse) {
        iCourse.studyCourse();
    }
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static void main(String[] args) {
    // v1 不使用依赖倒置原则
//        Geely geely = new Geely();
//        geely.studyJavaCourse();
//        geely.studyFECourse();
//        geely.studyPythonCourse();

    Geely geely = new Geely();
    geely.studyImoocCourse(new JavaCourse());
    geely.studyImoocCourse(new FECourse());
}
</code></pre></div></div>

<p><img src="/assets/markdown-img-paste-20180826105433811.png" alt="" /></p>

<p>上面这个示例：</p>

<ul>
  <li>geely 学习什么课程由 Test（应用层决定，高层模块）</li>
  <li>再学习其他的课程，只需要扩展课程即可。而 geely 不需要变动
    <ul>
      <li>在底层模块<strong>扩展</strong></li>
      <li>是扩展课程，而不是去修改已有的 JavaCourse ，这也符合了_开闭原则_</li>
    </ul>
  </li>
  <li>面向接口编程，而不是面对 Geely</li>
  <li>Test 与 Geely 是解耦的</li>
  <li>Gelly 与 具体的课程实现是解耦的</li>
  <li>Gelly 与 ICourse 是有依赖的</li>
  <li>所谓高内聚，低耦合，就是尽量减少耦合</li>
</ul>

<p>这里只是一种写法，</p>

<ul>
  <li>由方法参数传递进去，</li>
  <li>还可以从构造函数传递（不过这样一个 geely 实例就只能学习一种课程了）</li>
  <li>还可以设置一个set方法，每次学习前，把课程set进去</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// v3
// Geely geely = new Geely(new JavaCourse());
// geely.studyImoocCourse();

Geely geely = new Geely();
geely.setCourse(new JavaCourse())
geely.studyImoocCourse();

geely.setCourse(new FECourse())
geely.studyImoocCourse();
</code></pre></div></div>

<p>依赖倒置原则表现了一种事实：</p>

<ul>
  <li>相对于细节的多变性，抽象的东西要稳定得多</li>
  <li>以抽象搭建起来的架构，比以细节搭建起来的要稳定得多</li>
</ul>

<p>那么抽象的目的也就是：制定好规范和契约，如 ICourse 就是一种规范契约</p>

<h2 id="接口隔离原则">接口隔离原则</h2>

<p><strong>定义</strong>：用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口</p>

<ul>
  <li>一个类（泛指，）对一个类的依赖应该建立在虚小的接口上</li>
  <li>建立单一接口，不要建立庞大臃肿的接口</li>
  <li>尽量细化接口，接口中的方法尽量少</li>
  <li>
    <p><strong>注意湿度原则，一定要适度</strong></p>

    <p>如果只是尽可能的一个接口一个方法的话，那么接口类将爆炸，复杂性更高</p>
  </li>
</ul>

<p><strong>优点</strong>：符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的：</p>

<ul>
  <li>可读性</li>
  <li>可扩展性</li>
  <li>可维护性</li>
</ul>

<p>高内聚：减少对外的交互，使接口中最少的方法去完成最多的事情</p>

<p>一定要适度，在实际开发过程中，还要考虑业务模型，包括预判未来可能变更的地方</p>

<h4 id="coding-3">coding</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 动物行为</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IAnimalAction</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>

    <span class="kt">void</span> <span class="nf">fly</span><span class="o">();</span> <span class="c1">// 飞</span>

    <span class="kt">void</span> <span class="nf">swim</span><span class="o">();</span> <span class="c1">// 游泳</span>
<span class="o">}</span>

</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">IAnimalAction</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>

    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">fly</span><span class="o">()</span> <span class="o">{</span>
      <span class="c1">// 狗不会飞</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">swim</span><span class="o">()</span> <span class="o">{</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>对于狗来说，其他两种行为都ok，但是不会飞。假如再增加一种鸟类动物大雁，大雁不会游泳。</p>

<p>那么使用接口隔离原则来实现的一种可能：将接口拆分</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IEatAnimalAction</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IFlyAnimalAction</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">fly</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ISwimAnimalAction</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">swim</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Bird</span> <span class="kd">implements</span> <span class="nc">IFlyAnimalAction</span><span class="o">,</span> <span class="nc">IEatAnimalAction</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>

    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">fly</span><span class="o">()</span> <span class="o">{</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="/assets/markdown-img-paste-20180826141002886.png" alt="" /></p>

<p>这样就将行为给隔离开了。也不会有空实现方法了；</p>

<p>那么 单一职责原则和接口隔离原则有什么不同呢?</p>

<ul>
  <li>单一职责原则：约束的是类，接口，方法的<strong>职责</strong>是单一的
    <ul>
      <li>也就是说，在一个接口中，只要职责是单一的，有多个方法也可以</li>
      <li>如：游泳：有狗刨，自由泳等</li>
      <li>针对的是程序中的实现和细节</li>
    </ul>
  </li>
  <li>接口隔离原则：主要约束的是接口，
    <ul>
      <li>针对抽象，整体，程序框架的构建</li>
    </ul>
  </li>
</ul>

<p>还是适度，看项目规模、业务模型，不要一个简单的业务就搞了n个接口和类，开发起来也麻烦</p>

<h2 id="里氏替换原则">里氏替换原则</h2>

<p>Liskov Substitution Principle LSP</p>

<p>稍微有点难。不过不要慌</p>

<p><strong>定义</strong>：如果对每一个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，
使得以 T1 定义的所有程序 P 在所有的对象 o1 都替换成 o2 时，程序 P 的行为没有发生变化，
那么类型 T2 是类型 T1的子类型。</p>

<p>提取关键词解读：</p>

<ul>
  <li>T1 类有对象 o1</li>
  <li>T2 类有对象 o2</li>
  <li>P 程序</li>
</ul>

<p>当把程序中依赖 o1 对象全部替换成 o2 时，程序的行为没有发生变化。那么就可以认定为：T2 是 T1的子类型</p>

<p>里氏替换原则是对开闭原则的一个补充：</p>

<ul>
  <li>开闭原则：面向抽象编程，要抽象</li>
  <li>里氏替换原则：可以被替换，那么就有抽象；对实现抽象化的具体步骤规范</li>
</ul>

<p>比如：我们自定义一个类继承了ArrayList，但是重写get(indix)方法时，把索引改成从1开始了，
那么这样的虽然有抽象，但是行为发生了变化，这样也不被认为 自定义的是 ArrayList的子类型</p>

<blockquote>
  <p>上面这个比喻：我没有明白，懵逼了</p>
</blockquote>

<p><strong>定义扩展</strong>：一个软件实体如果适用一个父类的话，那一定适用于其子类，
所有引用父类的地方必须能透明地适用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变</p>

<p>在 java 中来说，只要只继承了某父类，那么就被认定为是其子类型，
但是对于里氏替换原则来说，就算继承了，但是导致替换后，行为发生了变化，则被认定为是不合法的</p>

<p><strong>引申意义</strong>：子类可以扩展父类的功能，但不能改变父类原有的功能。</p>

<ul>
  <li>含义 1：子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
  <li>
    <p>含义 2：子类中可以增加自己特有的方法。</p>

    <p>对于开闭原则中的例子如下，就有一个含义（含义 2）被破坏了，
JavaDiscountCourse 在扩展父类功能的时候，改变了 getPrice 的含义</p>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
       <span class="nc">ICourse</span> <span class="n">iCourse</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JavaDiscountCourse</span><span class="o">(</span><span class="mi">96</span><span class="o">,</span> <span class="s">"设计模式"</span><span class="o">,</span> <span class="mi">389</span><span class="n">d</span><span class="o">);</span>
       <span class="nc">JavaDiscountCourse</span> <span class="n">javaCourse</span> <span class="o">=</span> <span class="o">(</span><span class="nc">JavaDiscountCourse</span><span class="o">)</span> <span class="n">iCourse</span><span class="o">;</span>
       <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ID:"</span> <span class="o">+</span> <span class="n">javaCourse</span><span class="o">.</span><span class="na">getId</span><span class="o">()</span> <span class="o">+</span>
               <span class="s">"，课程名称："</span> <span class="o">+</span> <span class="n">javaCourse</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span>
               <span class="s">"，价格："</span> <span class="o">+</span> <span class="n">javaCourse</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">+</span>
               <span class="s">", 原价："</span> <span class="o">+</span> <span class="n">javaCourse</span><span class="o">.</span><span class="na">getOriginPrice</span><span class="o">()</span>
       <span class="o">);</span>
   <span class="o">}</span>
</code></pre></div>    </div>

    <p>通过上面的知识点来回想自己在实际工作中，经常会重写父类的方法，这样写起来的确简单快捷，
但是在一定程度上导致了整个继承体系的可复用性比较差，特别是使用多态频繁的时候，出错的几率会大大增加。</p>
  </li>
  <li>含义 3 ：当子类的方法<strong>重载</strong>父类的方法时，方法的前置条件（既方法的入参）要比父类的入参更宽松。</li>
  <li>含义 4 ：当子类的方法实现父类的方法时（重写/重载或实现抽象方法）方法的后置条件（及方法的返回值）要比如雷更严格或相等。</li>
</ul>

<p><strong>优点</strong>：</p>

<ul>
  <li>
    <p>约束继承泛滥，开闭原则的一种体现</p>

    <p>如：Persion 中有一个 生娃 的方法，子类可能有白人、黑人、黄种人，这是可以的，符合里氏替换原则。
但是，来一个男人，机器人，这就是一个继承泛滥的表现</p>
  </li>
  <li>
    <p>加强程序的健壮性，同时变更时也可以做到非常好的兼容性，提高程序的维护性，扩展性。
降低需求变更时引入的风险。</p>
  </li>
</ul>

<h4 id="coding-4">coding</h4>

<h4 id="从类层面演示">从类层面演示</h4>
<p><strong>场景</strong>：正方形和长方形，我们认为正方形是一种特殊的长方形。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 长方形</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Rectangle</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">length</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">width</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getLength</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">length</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLength</span><span class="o">(</span><span class="kt">long</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">length</span> <span class="o">=</span> <span class="n">length</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getWidth</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">width</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setWidth</span><span class="o">(</span><span class="kt">long</span> <span class="n">width</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">width</span> <span class="o">=</span> <span class="n">width</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 正方形：来验证在某些场景下，正方形是否是长方形</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Square</span> <span class="kd">extends</span> <span class="nc">Rectangle</span> <span class="o">{</span>
    <span class="c1">// 边长：正方形的长宽是一样的</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">sideLength</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getSideLength</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">sideLength</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSideLength</span><span class="o">(</span><span class="kt">long</span> <span class="n">sideLength</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">sideLength</span> <span class="o">=</span> <span class="n">sideLength</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getLength</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">getSideLength</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLength</span><span class="o">(</span><span class="kt">long</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">setSideLength</span><span class="o">(</span><span class="n">length</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getWidth</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">getSideLength</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setWidth</span><span class="o">(</span><span class="kt">long</span> <span class="n">width</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">setSideLength</span><span class="o">(</span><span class="n">width</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">resize</span><span class="o">(</span><span class="nc">Rectangle</span> <span class="n">rectangle</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">rectangle</span><span class="o">.</span><span class="na">getWidth</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">rectangle</span><span class="o">.</span><span class="na">getLength</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">rectangle</span><span class="o">.</span><span class="na">setWidth</span><span class="o">(</span><span class="n">rectangle</span><span class="o">.</span><span class="na">getWidth</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"width:"</span> <span class="o">+</span> <span class="n">rectangle</span><span class="o">.</span><span class="na">getWidth</span><span class="o">()</span> <span class="o">+</span>
                    <span class="s">"  length:"</span> <span class="o">+</span> <span class="n">rectangle</span><span class="o">.</span><span class="na">getLength</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"resize 方法结束：width:"</span> <span class="o">+</span> <span class="n">rectangle</span><span class="o">.</span><span class="na">getWidth</span><span class="o">()</span> <span class="o">+</span>
                <span class="s">"  length:"</span> <span class="o">+</span> <span class="n">rectangle</span><span class="o">.</span><span class="na">getLength</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Rectangle</span> <span class="n">rectangle</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Rectangle</span><span class="o">();</span>
        <span class="n">rectangle</span><span class="o">.</span><span class="na">setLength</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>
        <span class="n">rectangle</span><span class="o">.</span><span class="na">setWidth</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="n">resize</span><span class="o">(</span><span class="n">rectangle</span><span class="o">);</span>

        <span class="nc">Square</span> <span class="n">square</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Square</span><span class="o">();</span>
        <span class="n">square</span><span class="o">.</span><span class="na">setSideLength</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="n">resize</span><span class="o">(</span><span class="n">square</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>输出</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>width:20  length:20
width:21  length:20
resize 方法结束：width:21  length:20

width:239722  length:239722
width:239723  length:239723
</code></pre></div></div>

<p>会发现，在验证 resize 场景中，正方形是否是长方形这一子类的时候，替换之后，再次运行 resize 方法的时候，行为改变了，不能结束了；</p>

<p>那么这个时候就要考虑正方形继承长方形是否是正确的了，
假设之前的鸟类，我们认为飞的行为就是鸟类的特性，但是鸵鸟就是不能飞，强行让鸵鸟继承鸟，则有可能会造成与这里一致的情况。行为被改变了。</p>

<p>那么这里来继续重构，解耦正方形和长方形；他们都是四边形；</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Quadrangle</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="nf">getLength</span><span class="o">();</span>

    <span class="kt">long</span> <span class="nf">getWidth</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Rectangle</span> <span class="kd">implements</span> <span class="nc">Quadrangle</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">length</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">width</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLength</span><span class="o">(</span><span class="kt">long</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">length</span> <span class="o">=</span> <span class="n">length</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setWidth</span><span class="o">(</span><span class="kt">long</span> <span class="n">width</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">width</span> <span class="o">=</span> <span class="n">width</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getLength</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getWidth</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Square</span> <span class="kd">implements</span> <span class="nc">Quadrangle</span> <span class="o">{</span>
    <span class="c1">// 边长：正方形的长宽是一样的</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">sideLength</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getSideLength</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">sideLength</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSideLength</span><span class="o">(</span><span class="kt">long</span> <span class="n">sideLength</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">sideLength</span> <span class="o">=</span> <span class="n">sideLength</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getLength</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">getSideLength</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getWidth</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">getSideLength</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>那么就会发现，没有办法设置宽度了。对于 resize 场景来说，正方形是不适合该场景的；</p>

<p>所以这里还是只能用于长方形。说明了，长方形和正方形在该场景中不适合里氏替换原则的</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">resize</span><span class="o">(</span><span class="nc">Quadrangle</span> <span class="n">rectangle</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">rectangle</span><span class="o">.</span><span class="na">getWidth</span><span class="o">()</span> <span class="o">&lt;=</span> <span class="n">rectangle</span><span class="o">.</span><span class="na">getLength</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// 没有办法 setWidth</span>
        <span class="n">rectangle</span><span class="o">.</span><span class="na">setWidth</span><span class="o">(</span><span class="n">rectangle</span><span class="o">.</span><span class="na">getWidth</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"width:"</span> <span class="o">+</span> <span class="n">rectangle</span><span class="o">.</span><span class="na">getWidth</span><span class="o">()</span> <span class="o">+</span>
                <span class="s">"  length:"</span> <span class="o">+</span> <span class="n">rectangle</span><span class="o">.</span><span class="na">getLength</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"resize 方法结束：width:"</span> <span class="o">+</span> <span class="n">rectangle</span><span class="o">.</span><span class="na">getWidth</span><span class="o">()</span> <span class="o">+</span>
            <span class="s">"  length:"</span> <span class="o">+</span> <span class="n">rectangle</span><span class="o">.</span><span class="na">getLength</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p>通过这个例子，能深刻的理解里氏替换原则在我们软件设计中存在的巨大作用。</p>

<p>同时也约束我们，子类的行为与父类应该保持一致，如果子类达不到这一点，那么子类就会违反里氏替换原则。</p>

<p>在实际过程中，是多人协同开发的，甚至通过层层包装后，再使用，
如果这个时候，对于 resize 场景不采用里氏替换原则来约束，那么就将产生与预期不一致的行为，导致错误产生</p>

<h4 id="方法入参出参-来说明">方法入参出参 来说明</h4>
<ul>
  <li>含义 3 ：当子类的方法<strong>重载</strong>父类的方法时，方法的前置条件（既方法的入参）要比父类的入参更宽松。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Base</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="nc">HashMap</span> <span class="n">hashMap</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"父类被执行"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Child</span> <span class="kd">extends</span> <span class="nc">Base</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="nc">HashMap</span> <span class="n">hashMap</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"子类 HashMap 被执行"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 比父类入参更宽松，不是重写，是重载</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="nc">Map</span> <span class="n">map</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"子类 Map 被执行"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Test {
    public static void main(String[] args) {
        Child child = new Child();
        HashMap hashMap = new HashMap&lt;&gt;();
        child.method(hashMap);
    }
}

输出

子类 HashMap 被执行
</code></pre></div></div>

<p>当注释掉重写方法时，输出为 <code class="language-plaintext highlighter-rouge">父类被执行</code>;</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Child</span> <span class="kd">extends</span> <span class="nc">Base</span> <span class="o">{</span>
    <span class="c1">// @Override</span>
    <span class="c1">// public void method(HashMap hashMap) {</span>
    <span class="c1">//     System.out.println("子类 HashMap 被执行");</span>
    <span class="c1">// }</span>

    <span class="c1">// 比父类入参更宽松，不是重写，是重载</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="nc">Map</span> <span class="n">map</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"子类 Map 被执行"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>这个结果是正确的，那么反过来，将父类替换成</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Base</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="nc">Map</span> <span class="n">hashMap</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"父类被执行"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Child</span> <span class="kd">extends</span> <span class="nc">Base</span> <span class="o">{</span>
    <span class="c1">// 重载：子类的前置条件比父类严格</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="nc">HashMap</span> <span class="n">hashMap</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"子类 HashMap 被执行"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Child</span> <span class="n">child</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Child</span><span class="o">();</span>
        <span class="nc">HashMap</span> <span class="n">hashMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">child</span><span class="o">.</span><span class="na">method</span><span class="o">(</span><span class="n">hashMap</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>将会输出： 子类 HashMap 被执行</p>

<p>这就破坏了里氏替换原则，因为这样执行，不是父类的被执行了，容易引起业务逻辑的混乱。bug容易产生。</p>

<p>在写这个简单的例子的时候，就很容易被搞懵逼；</p>

<h4 id="后置条件也就是返回参数">后置条件，也就是返回参数</h4>
<ul>
  <li>含义 4 ：当子类的方法实现父类的方法时（重写/重载或实现抽象方法）方法的后置条件（及方法的返回值）要比如雷更严格或相等。</li>
</ul>

<p>在 java 中重写适合返回参数无关的，像下面这个例子，在 Idea 中就提示错误了，
所以这样的情况一般比较少犯错误，如果不写 override，那么就容易产生混乱。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 父类是 HashMap</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="nc">Map</span> <span class="nf">method</span><span class="o">()</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<p>实际上看来，这里的例子是在讲，多态，重写，重载，相似的新方法，容易产生逻辑混乱调用，不容易发现问题。 如果遵守里氏替换原则的写法，能减少这样的情况。维护性</p>

<p>还有就是里氏替换原则的约束继承泛滥的问题。</p>

<p>这一个原则理解起来感觉有点难，懵逼</p>

<h2 id="开闭原则">开闭原则</h2>

<p><strong>定义</strong>：一个软件实体如类，模块和函数应该对扩展开放，对修改关闭</p>

<p>开闭，是对扩展和修改两个行为的描述</p>

<p><strong>强调的是</strong>：用抽象构建框架，用实现扩展细节</p>

<p>优点：提高软件系统的可复用性及可维护性</p>

<p>在生活中有一个例子体现：每天工作 8 小时，8 小时是关闭的，什么时候来？什么时候走？这个是开放的</p>

<p><strong>开闭原则的核心</strong>：面向抽象编程，抽象相对来说是稳定的，对修改关闭；</p>

<p>如：一个校验逻辑，先校验什么，后校验什么。扩展一个校验，也就是功能增强，而不要去修改已有的校验功能，这是对修改关闭</p>

<h4 id="开闭原则-coding">开闭原则 coding</h4>

<p>一个场景：慕课网的课程表述；</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 课程
 * @author : zhuqiang
 * @version : V1.0
 * @date : 2018/8/23 23:38
 */</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ICourse</span> <span class="o">{</span>
    <span class="nc">Integer</span> <span class="nf">getId</span><span class="o">();</span>

    <span class="nc">String</span> <span class="nf">getName</span><span class="o">();</span>

    <span class="nc">Double</span> <span class="nf">getPrice</span><span class="o">();</span>
<span class="o">}</span>

</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">cn.mrcode.newstudy.design.pattern.principle.openclose</span><span class="o">;</span>

<span class="cm">/**
 * java 类课程;还有js，算法等课程，需要分开
 * @author : zhuqiang
 * @version : V1.0
 * @date : 2018/8/23 23:40
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JavaCourse</span> <span class="kd">implements</span> <span class="nc">ICourse</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Integer</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Double</span> <span class="n">price</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">JavaCourse</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">id</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">Double</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">price</span> <span class="o">=</span> <span class="n">price</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">getId</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">id</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Double</span> <span class="nf">getPrice</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">price</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<pre><code class="language-java{3}">public class Test {
    public static void main(String[] args) {
        JavaCourse javaCourse = new JavaCourse(96, "设计模式", 389d);
        System.out.println("ID:" + javaCourse.getId() +
                "，课程名称：" + javaCourse.getName() +
                "，价格：" + javaCourse.getPrice());
    }
}
</code></pre>

<p><img src="/assets/markdown-img-paste-20180824000236410.png" alt="" /></p>

<p>注意看现在的类图结构：JavaCourse 继承了 ICourse （实心箭头）</p>

<p>输出如下</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ID:96，课程名称：设计模式，价格：389.0
</code></pre></div></div>

<p><strong>需求2</strong>：双11到了，搞活动，打8折</p>

<p>那么方案有以下几种，都能满足需求，来说说不足的地方</p>

<ol>
  <li>直接在输出的地方价格乘以 0.8
    <ul>
      <li>如果只是某些课程打折呢？</li>
    </ul>
  </li>
  <li>在 JavaCourse 类中 getPrice 方法中乘以 0.8
    <ul>
      <li>如果要获取原价呢?</li>
      <li>如果还有要求说是价格大于300的课程才打折呢？</li>
    </ul>
  </li>
  <li>在 ICourse 接口中增加打折方法：discountCourse
    <ul>
      <li>如果有很多课程，那么影响范围巨大，除非一开始就已经定义了这种接口</li>
    </ul>
  </li>
</ol>

<p>一看业务变化，上面的方案对于维护来说都是个不好的办法，那么应该怎么办呢？</p>

<p><strong>开闭原则</strong>：模块和函数应该对扩展开放，对修改关闭</p>

<p>那么增加一个打折的子类即可；</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">cn.mrcode.newstudy.design.pattern.principle.openclose</span><span class="o">;</span>

<span class="cm">/**
 * java课程打折
 * @author : zhuqiang
 * @version : V1.0
 * @date : 2018/8/24 0:13
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JavaDiscountCourse</span> <span class="kd">extends</span> <span class="nc">JavaCourse</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">JavaDiscountCourse</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">id</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">Double</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">price</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Double</span> <span class="nf">getPrice</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 这里可以针对业务进行范围的判定等操作</span>
        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">*</span> <span class="mf">0.8</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/** 获取原价 */</span>
    <span class="kd">public</span> <span class="nc">Double</span> <span class="nf">getOriginPrice</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">getPrice</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">ICourse</span> <span class="n">iCourse</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JavaDiscountCourse</span><span class="o">(</span><span class="mi">96</span><span class="o">,</span> <span class="s">"设计模式"</span><span class="o">,</span> <span class="mi">389</span><span class="n">d</span><span class="o">);</span>
    <span class="nc">JavaDiscountCourse</span> <span class="n">javaCourse</span> <span class="o">=</span> <span class="o">(</span><span class="nc">JavaDiscountCourse</span><span class="o">)</span> <span class="n">iCourse</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ID:"</span> <span class="o">+</span> <span class="n">javaCourse</span><span class="o">.</span><span class="na">getId</span><span class="o">()</span> <span class="o">+</span>
            <span class="s">"，课程名称："</span> <span class="o">+</span> <span class="n">javaCourse</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span>
            <span class="s">"，价格："</span> <span class="o">+</span> <span class="n">javaCourse</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">+</span>
            <span class="s">", 原价："</span> <span class="o">+</span> <span class="n">javaCourse</span><span class="o">.</span><span class="na">getOriginPrice</span><span class="o">()</span>
    <span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>输出如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ID:96，课程名称：设计模式，价格：311.20000000000005, 原价：389.0
</code></pre></div></div>

<p><img src="/assets/markdown-img-paste-20180824001852665.png" alt="" /></p>

<p>看现在的类图：这里没有严格按照我们之前讲解的图形来演示，而是有颜色和标识，反正差别不大，更容易看明白</p>

<p>主要是这里的类图结构和增强之前的类图结构对比；阐述了开闭原则，而对于上面所说的那些维护问题相对来说也更方便维护，结构上也更容易理解（杠精请绕道，一般的web开发，基本上不会这样做）</p>

<h2 id="单一职责原则">单一职责原则</h2>

<p><strong>定义</strong>：不要存在多于一个导致类变更的原因</p>

<p>理解：比如：一个类负责了 2 个功能，在修改功能 1 时，导致功能 2 发生了故障；两个功能在需求变更的时候都有可能导致类变更，那么该类存在两个导致类变更的原因</p>

<p><strong>体现</strong>： 一个类、接口、方法只负责一项职责</p>

<p><strong>优点</strong>：</p>

<ul>
  <li>降低类的复杂度</li>
  <li>提高类的可读性</li>
  <li>提高系统的可维护性</li>
  <li>降低变更引起的风险
    <ul>
      <li>变更是必然的，单一职责原则遵循的好，可以降低变更引起的风险</li>
      <li>单一职责也适用于模块化设计</li>
    </ul>
  </li>
</ul>

<p>开始coding</p>

<h4 id="基本场景">基本场景</h4>
<p>场景：鸟的动作</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Bird</span> <span class="o">{</span>
    <span class="c1">// 主要移动方式</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">mainMoveMode</span><span class="o">(</span><span class="nc">String</span> <span class="n">birdName</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">birdName</span> <span class="o">+</span> <span class="s">"用翅膀飞"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Bird</span> <span class="n">bird</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Bird</span><span class="o">();</span>
        <span class="n">bird</span><span class="o">.</span><span class="na">mainMoveMode</span><span class="o">(</span><span class="s">"大雁"</span><span class="o">);</span>
        <span class="n">bird</span><span class="o">.</span><span class="na">mainMoveMode</span><span class="o">(</span><span class="s">"鸵鸟"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>大雁用翅膀飞
鸵鸟用翅膀飞
</code></pre></div></div>

<p>这里的结果就有问题了：鸵鸟主要移动方式是用脚走路。那么进行修改</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Bird</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">mainMoveMode</span><span class="o">(</span><span class="nc">String</span> <span class="n">birdName</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="s">"鸵鸟"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">birdName</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">birdName</span> <span class="o">+</span> <span class="s">"用脚走"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">birdName</span> <span class="o">+</span> <span class="s">"用翅膀飞"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个示例说实在的，我自己平时在开发的时候就经常这样做，这样做的原因有多种，比如</p>

<ul>
  <li>时间关系</li>
  <li>感觉这个业务不怎么复杂，这样改动是最方便最快捷的</li>
</ul>

<p>如果还有更多的不同移动方式的鸟类呢？这里的逻辑则会更多的判定。如果在一段很复杂的业务逻辑中，就很容易出错。这里就破坏了单一职责原则-降低变更引起的风险</p>

<h4 id="类单一职责演示">类单一职责演示</h4>
<p>把上面负责多职责的拆分成单一职责</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 会飞的鸟</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FlyBird</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">mainMoveMode</span><span class="o">(</span><span class="nc">String</span> <span class="n">birdName</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">birdName</span> <span class="o">+</span> <span class="s">"用翅膀飞"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 用脚走的鸟</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WalkBird</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">mainMoveMode</span><span class="o">(</span><span class="nc">String</span> <span class="n">birdName</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">birdName</span> <span class="o">+</span> <span class="s">"用脚走"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>由应用层来判定，什么鸟适合什么行走方式</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FlyBird</span> <span class="n">flyBird</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FlyBird</span><span class="o">();</span>
<span class="n">flyBird</span><span class="o">.</span><span class="na">mainMoveMode</span><span class="o">(</span><span class="s">"大雁"</span><span class="o">);</span>

<span class="nc">WalkBird</span> <span class="n">walkBird</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WalkBird</span><span class="o">();</span>
<span class="n">walkBird</span><span class="o">.</span><span class="na">mainMoveMode</span><span class="o">(</span><span class="s">"鸵鸟"</span><span class="o">);</span>
</code></pre></div></div>

<p><img src="/assets/markdown-img-paste-20180826131725881.png" alt="" /></p>

<h4 id="接口级别">接口级别</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ICourse</span> <span class="o">{</span>
    <span class="c1">// ~-----------  课程信息</span>
    <span class="nc">String</span> <span class="nf">getCourseName</span><span class="o">();</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="nf">getCourseVideo</span><span class="o">();</span>

    <span class="c1">// ~-----------  课程管理</span>
    <span class="cm">/** 学习课程 */</span>
    <span class="kt">void</span> <span class="nf">studyCourrse</span><span class="o">();</span>
    <span class="cm">/** 退款这门课程 */</span>
    <span class="kt">void</span> <span class="nf">refundCourse</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>对于这个接口来说，有两个大的职责：获取课程信息和课程管理。</p>

<p>如果当课程被退掉的时候，这门课程的信息就获取不到了，也就是说 refundCourse 会影响获取课程信息相关的功能。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ICourseContent</span> <span class="o">{</span>
    <span class="c1">// ~-----------  课程信息</span>
    <span class="nc">String</span> <span class="nf">getCourseName</span><span class="o">();</span>

    <span class="kt">byte</span><span class="o">[]</span> <span class="nf">getCourseVideo</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ICourseManager</span> <span class="o">{</span>
    <span class="c1">// ~-----------  课程管理</span>
    <span class="cm">/** 学习课程 */</span>
    <span class="kt">void</span> <span class="nf">studyCourrse</span><span class="o">();</span>
    <span class="cm">/** 退款这门课程 */</span>
    <span class="kt">void</span> <span class="nf">refundCourse</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CourseImpl</span> <span class="kd">implements</span> <span class="nc">ICourseContent</span><span class="o">,</span> <span class="nc">ICourseManager</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getCourseName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">getCourseVideo</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">studyCourrse</span><span class="o">()</span> <span class="o">{</span>

    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">refundCourse</span><span class="o">()</span> <span class="o">{</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="/assets/markdown-img-paste-20180826133031296.png" alt="" /></p>

<p>由具体的实现选择来组合实现哪些功能（也可以只实现其中一个），</p>

<ul>
  <li>在接口级别上两个接口的职责是清晰的，隔离的。</li>
  <li>复杂度也降低了，可读性也变高了</li>
  <li>降低变更引起的风险，可维护性变高了</li>
  <li>一个接口的修改不影响另一个接口的功能</li>
</ul>

<h4 id="方法级别">方法级别</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateUserInfo</span><span class="o">(</span><span class="nc">String</span> <span class="n">userName</span><span class="o">,</span> <span class="nc">String</span> <span class="n">address</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">bool</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">bool</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 逻辑1</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 逻辑2</span>
        <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这种的逻辑，很明确的是两个功能逻辑，就可以完全拆分成两个方法来处理这不同的功能，而不是用一个标志来处理</p>]]></content><author><name>Rise1024</name></author><category term="设计模式" /><summary type="html"><![CDATA[简单工厂模式]]></summary></entry><entry><title type="html">安全漏洞-CSRF漏洞</title><link href="http://localhost:4000/%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E.html" rel="alternate" type="text/html" title="安全漏洞-CSRF漏洞" /><published>2022-05-19T03:32:20+08:00</published><updated>2022-05-19T03:32:20+08:00</updated><id>http://localhost:4000/%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E</id><content type="html" xml:base="http://localhost:4000/%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E.html"><![CDATA[<h2 id="csrf漏洞攻击与防御">CSRF漏洞攻击与防御</h2>

<h3 id="什么是csrf漏洞">什么是CSRF漏洞</h3>
<p>   攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。
<img src="../assets/img/posts/20220519/img1.png" alt="img.png" /></p>
<h3 id="攻击实例">攻击实例</h3>

<p>   受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。</p>

<p>  黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。</p>

<p>  这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。</p>

<h3 id="防御csrf漏洞">防御CSRF漏洞</h3>

<p>  目前防御 CSRF 攻击主要有三种策略：</p>

<p><strong>验证 HTTP Referer 字段&lt;/br&gt;</strong>
<strong>在请求地址中添加 token 并验证&lt;/br&gt;</strong>
<strong>在 HTTP 头中自定义属性并验证&lt;/br&gt;</strong></p>

<h4 id="1验证-http-referer-字段">(1)验证 HTTP Referer 字段</h4>

<p>  根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p>

<p>  这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p>

<p>  然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。</p>

<p>  即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p>

<h4 id="2在请求地址中添加-token-并验证">(2)在请求地址中添加 token 并验证</h4>

<p>  CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>

<p>  这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 &lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt;，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p>

<p>  该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p>

<h4 id="3在-http-头中自定义属性并验证">(3)在 HTTP 头中自定义属性并验证</h4>

<p>  这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>

<p>  然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>

<h4 id="所以综上所述对于csrf的防护要结合自身系统情况做出相应的调整">所以综上所述，对于CSRF的防护要结合自身系统情况，做出相应的调整</h4>]]></content><author><name>Rise1024</name></author><category term="安全漏洞" /><summary type="html"><![CDATA[安全漏洞]]></summary></entry><entry><title type="html">单点登录机制</title><link href="http://localhost:4000/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%9C%BA%E5%88%B6.html" rel="alternate" type="text/html" title="单点登录机制" /><published>2022-05-17T03:32:20+08:00</published><updated>2022-05-17T03:32:20+08:00</updated><id>http://localhost:4000/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%9C%BA%E5%88%B6</id><content type="html" xml:base="http://localhost:4000/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%9C%BA%E5%88%B6.html"><![CDATA[<h3 id="什么是单点登录">什么是单点登录</h3>

<p>简称为 SSO，SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p>

<p>单点登录基本流程如下：</p>

<p>1）当用户第一次访问应用系统的时候，因为还没有登录，会被引导到认证系统中进行登录；</p>

<p>2）根据用户提供的登录信息，认证系统进行身份校验，如果通过校验，应该返回给用户一个认证的凭据－－ticket；</p>

<p>3）用户再访问别的应用的时候，就会将这个ticket带上，作为自己认证的凭据，应用系统接受到请求之后会把ticket送到认证系统进行校验，检查ticket的合法性。如果通过校验，用户就可以在不用再次登录的情况下访问应用系统2和应用系统3了。</p>

<p><img src="/assets/img/posts/20220516/dandian1.png" alt="posts/20220516/fengmian.jpeg" /></p>
<h3 id="普通的登录认证机制">普通的登录认证机制</h3>

<p><img src="/assets/img/posts/20220516/dandian2.png" alt="posts/20220516/fengmian.jpeg" /></p>

<p>如上图所示，我们在浏览器（Browser）中访问一个应用，这个应用需要登录，我们填写完用户名和密码后，完成登录认证。这时，我们在这个用户的session中标记登录状态为yes（已登录），同时在浏览器（Browser）中写入Cookie，这个Cookie是这个用户的唯一标识。下次我们再访问这个应用的时候，请求中会带上这个Cookie，服务端会根据这个Cookie找到对应的session，通过session来判断这个用户是否登录。如果不做特殊配置，这个Cookie的名字叫做jsessionid，值在服务端（server）是唯一的。</p>

<blockquote>
  <p>Cookie</p>
</blockquote>

<p>　　<strong><em>Cookie技术是http状态保持在客户端的解决方案</em></strong>，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。</p>

<blockquote>
  <p>Cookie的内容、作用域以及有效期</p>
</blockquote>

<p>　　cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域合在一起就构成了cookie的作用范围。<strong><em>如果不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了，这种生命期为浏览器会话期的 cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里。如果设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间</em></strong>。</p>

<blockquote>
  <p>Session</p>
</blockquote>

<p>　　Session一般叫做回话，<strong><em>Session技术是http状态保持在服务端的解决方案</em></strong>，它是通过服务器来保持状态的。我们可以把客户端浏览器与服务器之间一系列交互的动作称为一个 Session。是服务器端为客户端所开辟的存储空间，在其中保存的信息就是用于保持状态。因此，session是解决http协议无状态问题的服务端解决方案，它能让客户端和服务端一系列交互动作变成一个完整的事务。</p>

<blockquote>
  <p>Session的创建</p>
</blockquote>

<p>　　那么Session在何时创建呢？当然还是在服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同创建Session的方法。</p>

<p>当客户端第一次请求服务端，当server端程序调用HttpServletRequest.getSession(true)这样的语句时的时候，服务器会为客户端创建一个session，并将通过特殊算法算出一个session的ID，用来标识该session对象。</p>

<p>　　Session存储在服务器的内存中(tomcat服务器通过StandardManager类将session存储在内存中)，也可以持久化到file，数据库，memcache，redis等。客户端只保存sessionid到cookie中，而不会保存session。</p>

<p>　　浏览器的关闭并不会导致Session的删除，只有当超时、程序调用HttpSession.invalidate()以及服务端程序关闭才会删除。</p>

<blockquote>
  <p>Cookie与Session的关系</p>
</blockquote>

<p>　　cookie和session的方案虽然分别属于客户端和服务端，但是服务端的session的实现对客户端的cookie有依赖关系的，服务端执行session机制时候会生成session的id值，这个id值会发送给客户端，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，而这个id值在客户端会保存下来，保存的容器就是cookie，因此当我们完全禁掉浏览器的cookie的时候，服务端的session也会不能正常使用。</p>

<blockquote>
  <p>同域单点登录</p>
</blockquote>

<p>一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com和app2.a.com。我们要做单点登录（SSO），需要一个登录系统，叫做：sso.a.com。</p>

<p>我们只要在sso.a.com登录，app1.a.com和app2.a.com就也登录了。通过上面的登陆认证机制，我们可以知道，在sso.a.com中登录了，其实是在sso.a.com的服务端的session中记录了登录状态，同时在浏览器端（Browser）的sso.a.com下写入了Cookie。那么我们怎么才能让app1.a.com和app2.a.com登录呢？这里有两个问题：</p>

<p>Cookie是不能跨域的，我们Cookie的domain属性是sso.a.com，在给app1.a.com和app2.a.com发送请求是带不上的。</p>

<p>sso、app1和app2是不同的应用，它们的session存在自己的应用内，是不共享的。</p>

<p><img src="/assets/img/posts/20220516/dandian3.png" alt="posts/20220516/fengmian.jpeg" /></p>

<p>那么我们如何解决这两个问题呢？针对第一个问题，sso登录以后，可以将Cookie的域设置为顶域，即.a.com，这样所有子域的系统都可以访问到顶域的Cookie。我们在设置Cookie时，只能设置顶域和自己的域，不能设置其他的域。比如：我们不能在自己的系统中给baidu.com的域设置Cookie。</p>

<p>Cookie的问题解决了，我们就需要来看看session的问题。我们在sso系统登录了，这时再访问app1，Cookie也带到了app1的服务端（Server），app1的服务端怎么找到这个Cookie对应的Session呢？这里就要把3个系统的Session共享，如图所示。共享Session的解决方案有很多，例如：Spring-Session。这样第2个问题也解决了。</p>]]></content><author><name>Rise1024</name></author><category term="JAVA技术框架" /><summary type="html"><![CDATA[单点登录详解]]></summary></entry></feed>